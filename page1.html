<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Quantum Forge — Linear + Cheats</title>
<style>
  :root{ color-scheme: dark; }
  html,body{height:100%;margin:0;background:#090c10;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  canvas{display:block;position:fixed;inset:0;width:100%;height:100%}
  *{ -webkit-tap-highlight-color: transparent; user-select: none; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
(function(){
  'use strict';
  const CANVAS=document.getElementById('game');
  const CTX=CANVAS.getContext('2d',{alpha:false});
  let DPR=Math.max(1,Math.min(3,(window.devicePixelRatio||1)));
  let CLICK_EPS=6;

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const nowMs=()=>performance.now();
  const rand=(a,b)=>a+Math.random()*(b-a);
  const fmt=(n)=>{ if(!isFinite(n))return'∞'; if(n<1000)return n.toFixed(n<10?2:n<100?1:0);
    const U=['','K','M','B','T','Qa','Qi','Sx','Sp','Oc','No','Dc']; let i=0,x=n; while(x>=1000&&i<U.length-1){x/=1000;i++;} return x.toFixed(x<10?2:x<100?1:0)+U[i];
  };
  const measure=(txt,size,weight='600')=>{CTX.font=`${weight} ${size}px Inter,system-ui`;return CTX.measureText(txt).width;};

  function resize(){
    DPR=Math.max(1,Math.min(3,(window.devicePixelRatio||1)));
    const w=Math.max(320,Math.floor(CANVAS.clientWidth*DPR));
    const h=Math.max(320,Math.floor(CANVAS.clientHeight*DPR));
    if(CANVAS.width!==w||CANVAS.height!==h){CANVAS.width=w;CANVAS.height=h;}
  }
  window.addEventListener('resize',resize,{passive:true}); resize();

  const input={mx:0,my:0,down:false,wheel:0};
  let prevDown=false;
  function canvasPos(evt){const r=CANVAS.getBoundingClientRect();return {x:(evt.clientX-r.left)*DPR,y:(evt.clientY-r.top)*DPR};}

  function onPointerMove(e){
    const p=canvasPos(e); input.mx=p.x; input.my=p.y;
    const dr=state.ui.scrollDrag;
    if(dr.active&&dr.tab===state.tab){
      const dy=input.my-dr.lastY; const max=state.ui.maxScroll||0;
      state.scroll[state.tab]=clamp((state.scroll[state.tab]||0)-dy,0,max);
      dr.vy=dy; dr.lastY=input.my;
    }
  }
  function onPointerDown(e){
    const p=canvasPos(e); input.mx=p.x; input.my=p.y; input.down=true;
    if(state.arcade.active && state.arcade.mode==='gate'){
      gateStop();
      return;
    }
    const r=state.ui.sideRect;
    if(r && input.mx>=r.x && input.mx<=r.x+r.w && input.my>=r.y && input.my<=r.y+r.h){
      state.ui.scrollDrag={active:true,lastY:input.my,vy:0,tab:state.tab};
    }
  }
  function onPointerUp(e){
    const p=canvasPos(e); input.mx=p.x; input.my=p.y; input.down=false;
    if(state.ui.scrollDrag.active){
      state.ui.scrollVel+=-state.ui.scrollDrag.vy*0.8;
      state.ui.scrollDrag={active:false,lastY:0,vy:0,tab:null};
    }
    dispatchClick(p.x,p.y);
  }
  if(window.PointerEvent){
    CANVAS.addEventListener('pointermove',onPointerMove);
    CANVAS.addEventListener('pointerdown',onPointerDown);
    CANVAS.addEventListener('pointerup',onPointerUp);
  }else{
    CANVAS.addEventListener('mousemove',e=>{const p=canvasPos(e);input.mx=p.x;input.my=p.y;});
    CANVAS.addEventListener('mousedown',onPointerDown);
    CANVAS.addEventListener('mouseup',onPointerUp);
    CANVAS.addEventListener('touchstart',e=>{const t=e.changedTouches[0];const r=CANVAS.getBoundingClientRect();input.mx=(t.clientX-r.left)*DPR;input.my=(t.clientY-r.top)*DPR;input.down=true;e.preventDefault();},{passive:false});
    CANVAS.addEventListener('touchend',e=>{const t=e.changedTouches[0];const r=CANVAS.getBoundingClientRect();const x=(t.clientX-r.left)*DPR,y=(t.clientY-r.top)*DPR;input.down=false;dispatchClick(x,y);},{passive:true});
  }
  CANVAS.addEventListener('wheel',e=>{input.wheel+=e.deltaY;},{passive:true});

  window.addEventListener('keydown',(e)=>{
    if(state.arcade.active){
      if(state.arcade.mode==='gate'&&(e.code==='Space'||e.key===' ')) gateStop();
      if(e.key==='Escape') endArcade();
      return;
    }
    if(e.key==='e'||e.key==='E') doExport();
    if(e.key==='i'||e.key==='I') doImport();
    if(e.key==='p'||e.key==='P') tryAscend();
    if(e.key==='m'||e.key==='M') state.settings.mute=!state.settings.mute;
    if(e.key==='-') cycleBuyQty(-1);
    if(e.key==='=') cycleBuyQty(+1);
    const idx='1234567890'.indexOf(e.key); if(idx!==-1) buyModule(idx);
  });

  let AC=null; function beep(f=420,d=0.05,v=0.02,type='triangle'){ if(state.settings.mute) return; try{ AC=AC||new (window.AudioContext||window.webkitAudioContext)(); const o=AC.createOscillator(),g=AC.createGain(); o.type=type;o.frequency.value=f;g.gain.value=v;o.connect(g);g.connect(AC.destination);o.start();o.stop(AC.currentTime+d);}catch{} }

  // ===== SHOP =====
  const MODULES=[
    {id:0,name:'Nanite Swarm', base:20,   mult:1.15, prod:0.14},
    {id:1,name:'Signal Printer', base:130, mult:1.15, prod:1.1},
    {id:2,name:'Biofarm',       base:1400, mult:1.15, prod:7.5},
    {id:3,name:'Ore Synth',     base:16000,mult:1.15, prod:44},
    {id:4,name:'Assembler',     base:175000,mult:1.15, prod:230},
    {id:5,name:'Credit Node',   base:1900000,mult:1.15, prod:1100},
    {id:6,name:'Research Lab',  base:26000000,mult:1.15, prod:6200, rp:0.06},
    {id:7,name:'Flux Shrine',   base:380000000,mult:1.15, prod:35000},
    {id:8,name:'Time Fork',     base:5500000000,mult:1.15, prod:210000},
    {id:9,name:'Singularity',   base:82000000000,mult:1.15, prod:1300000},
    {id:10,name:'Quantum Loom',       base:1200000000000,mult:1.15, prod:8200000},
    {id:11,name:'Quantum Institute',  base:18000000000000,mult:1.15, prod:54000000, rp:0.12},
    {id:12,name:'Grav Well',          base:270000000000000,mult:1.15, prod:210000000},
    {id:13,name:'Star Foundry',       base:4000000000000000,mult:1.15, prod:900000000},
    {id:14,name:'Cosmic Lattice',     base:65000000000000000,mult:1.15, prod:3500000000},
    {id:15,name:'Omega Array',        base:1000000000000000000,mult:1.15, prod:15000000000},
    {id:16,name:'Neutrino Net',       base:1e21,mult:1.15, prod:6e10},
    {id:17,name:'Axion Furnace',      base:1e23,mult:1.15, prod:2.4e11},
    {id:18,name:'Quasar Loom',        base:2.5e24,mult:1.15, prod:1.1e12},
    {id:19,name:'Dark-Matter Mill',   base:7.5e25,mult:1.15, prod:4.8e12},
    {id:20,name:'Chrono Array',       base:2e27,mult:1.15, prod:2.1e13, rp:0.25}
  ];

  const state={
    __version:9,
    bits:0,bitsTotal:0,lifetimeBits:0,
    rp:0,rpTotal:0,
    clickBase:1,clickMult:1,
    charge:{active:false,t:0,tMax:1.6},
    critZone:{lo:0.92,hi:1.0,mult:3},
    combo:{v:0,max:0.5,decay:0.12},
    modules:MODULES.map(m=>({id:m.id,count:0})),
    upgrades:[],tech:[],achievements:[],
    ascend:{cores:0,best:0},
    settings:{particles:true,mute:false,lowFX:false},
    // hidden cheat
    cheat:{unlocked:false,taps:0,req:50,x10:false},
    lastSave:Date.now(),
    tab:'Forge',buyQtyIndex:0,
    // research category tab index
    researchCat:0,
    scroll:{Forge:0,Shop:0,Research:0,Arcade:0,Achievements:0,Stats:0,Ascend:0,Settings:0,Cheats:0},
    glitch:{next:rand(18,40),life:0,x:0,y:0,active:false,value:0},
    rift:{timer:rand(140,220),active:false,hp:0,hpMax:0,bitsReward:0,rpReward:0,prize:'bits',ttl:0,open:0,closing:false,wobble:0,stars:[]},
    particles:[],toast:[],
    arcade:{active:false,mode:null,t:0,score:0,pulses:[],gate:{x:0,v:0.9,zone:[0.45,0.55],tries:8}},
    clickArea:null,
    ui:{
      drawerOpen:false,scale:1,sideRect:null,maxScroll:0,
      scrollDrag:{active:false,lastY:0,vy:0,tab:null},scrollVel:0
    },
  };

  const mults={global:1,modules:1,glitch:1,combo:1};
  const mods={clickCurve:1,rpGain:1,arcadeReward:1,riftHP:1,gateZone:1,pulseSize:1,pulseLife:1,costMult:1,glitchRate:1,riftReward:1};
  const BUY_QTY=[1,10,100,'Max'];

  // ===== RESEARCH TREES (linear categories) =====
  const TREES=[
    {name:'Core', id:'core', items:[
      {id:'t_over1',tier:0,rp:50, pre:[],             name:'Overclock I',     desc:'+10% global',       apply:()=>{mults.global*=1.10;}},
      {id:'t_curve',tier:0,rp:25, pre:[],             name:'Harmonic Clicks', desc:'Pulses hit harder',  apply:()=>{mods.clickCurve*=1.5;}},
      {id:'t_glitch',tier:1,rp:80, pre:['t_over1'],   name:'Glitch Magnet',   desc:'+50% Glitch orbs',  apply:()=>{mults.glitch*=1.5;}},
      {id:'t_combo', tier:1,rp:150,pre:['t_curve'],   name:'Flux Combo',      desc:'Higher combo cap',   apply:()=>{state.combo.max=0.8; state.combo.decay=0.09;}},
      {id:'t_over2',tier:2,rp:200,pre:['t_over1'],    name:'Overclock II',    desc:'+20% global',       apply:()=>{mults.global*=1.20;}},
      {id:'t_corecrit',tier:2,rp:200,pre:['t_curve'], name:'Widen Crit',      desc:'Wider crit arc',     apply:()=>{state.critZone.lo=Math.max(0,state.critZone.lo-0.05); state.critZone.hi=Math.min(1,state.critZone.hi+0.02);}},
      {id:'t_over3',tier:3,rp:450,pre:['t_over2'],    name:'Overclock III',   desc:'+25% global',       apply:()=>{mults.global*=1.25;}},
      {id:'t_click2',tier:3,rp:500,pre:['t_curve'],   name:'Pulse Overdrive', desc:'+50% click payout', apply:()=>{state.clickMult*=1.5;}},
      {id:'t_over4',tier:4,rp:950,pre:['t_over3'],    name:'Overclock IV',    desc:'+30% global',       apply:()=>{mults.global*=1.30;}},
      {id:'t_crit2', tier:4,rp:700,pre:['t_corecrit'],name:'Critical Expansion',desc:'Even wider crit',  apply:()=>{state.critZone.lo=Math.max(0,state.critZone.lo-0.03); state.critZone.hi=Math.min(1,state.critZone.hi+0.02);}},
      {id:'t_charge1',tier:4,rp:680,pre:['t_over2'],  name:'Charge Tuning I', desc:'Charge fills faster',apply:()=>{state.charge.tMax=Math.max(1.2,state.charge.tMax*0.92);}},
      {id:'t_over5',tier:5,rp:1600,pre:['t_over4'],   name:'Overclock V',     desc:'+35% global',       apply:()=>{mults.global*=1.35;}},
      {id:'t_click3',tier:5,rp:1400,pre:['t_click2'], name:'Pulse Overdrive II',desc:'+75% click payout',apply:()=>{state.clickMult*=1.75;}},
      {id:'t_charge2',tier:5,rp:1200,pre:['t_charge1'],name:'Charge Tuning II',desc:'Charge much faster', apply:()=>{state.charge.tMax=Math.max(1.1,state.charge.tMax*0.88);}}
    ]},
    {name:'Labs', id:'labs', items:[
      {id:'t_lab',    tier:0,rp:120,pre:['t_over1'],     name:'Lab Protocols',    desc:'+60% RP gain',      apply:()=>{mods.rpGain*=1.6;}},
      {id:'t_riftdmp',tier:1,rp:300,pre:['t_lab'],       name:'Rift Dampers',     desc:'Rifts easier',       apply:()=>{mods.riftHP*=0.8;}},
      {id:'t_lab2',   tier:2,rp:700,pre:['t_lab'],       name:'Institute Grants', desc:'+50% RP gain',      apply:()=>{mods.rpGain*=1.5;}},
      {id:'t_rift2',  tier:3,rp:900,pre:['t_riftdmp'],   name:'Rift Shunts',      desc:'Rifts even easier',  apply:()=>{mods.riftHP*=0.85;}},
      {id:'t_mods',   tier:4,rp:600,pre:['t_over3'],     name:'Module Eff.',      desc:'+20% modules',      apply:()=>{mults.modules*=1.2;}},
      {id:'t_lab3',   tier:4,rp:1200,pre:['t_lab2'],     name:'Grand Fellowship', desc:'+45% RP gain',      apply:()=>{mods.rpGain*=1.45;}},
      {id:'t_cost1',  tier:5,rp:900,pre:['t_mods'],      name:'Bulk Procurement', desc:'Shop costs -5%',     apply:()=>{mods.costMult*=0.95;}},
      {id:'t_cost2',  tier:6,rp:1500,pre:['t_cost1'],    name:'Megascale Contracts',desc:'Shop costs -8%',    apply:()=>{mods.costMult*=0.92;}},
      {id:'t_rift3',  tier:6,rp:1400,pre:['t_rift2'],    name:'Rift Nullifiers',  desc:'Rifts trivialized',  apply:()=>{mods.riftHP*=0.85;}},
      {id:'t_riftrew',tier:6,rp:1300,pre:['t_rift2'],    name:'Rift Dividends',   desc:'+40% Rift rewards', apply:()=>{mods.riftReward*=1.4;}},
      {id:'t_glitchrate',tier:3,rp:700,pre:['t_glitch'], name:'Glitch Beacon',    desc:'More Glitch spawns', apply:()=>{mods.glitchRate*=1.35;}}
    ]},
    {name:'Arcade', id:'arcade', items:[
      {id:'t_gate',   tier:0,rp:220,pre:['t_curve'],     name:'Gate Precision',   desc:'Easier Timing Gate',   apply:()=>{mods.gateZone*=1.25;}},
      {id:'t_pulse',  tier:0,rp:180,pre:['t_curve'],     name:'Pulse Tuning',     desc:'Bigger/longer Pulse',  apply:()=>{mods.pulseSize*=1.15; mods.pulseLife*=1.2;}},
      {id:'t_arcade', tier:1,rp:260,pre:['t_lab'],       name:'Arcade Grants',    desc:'+30% arcade rewards', apply:()=>{mods.arcadeReward*=1.3;}},
      {id:'t_arcade2',tier:2,rp:520,pre:['t_arcade'],    name:'Arcade Stipend',   desc:'+25% arcade rewards', apply:()=>{mods.arcadeReward*=1.25;}},
      {id:'t_pulse2', tier:3,rp:600,pre:['t_pulse'],     name:'Pulse Tuning II',  desc:'Even bigger/longer',   apply:()=>{mods.pulseSize*=1.2; mods.pulseLife*=1.2;}},
      {id:'t_gate2',  tier:3,rp:620,pre:['t_gate'],      name:'Gate Precision II',desc:'Much easier Gate',     apply:()=>{mods.gateZone*=1.2;}},
      {id:'t_arcade3',tier:4,rp:820,pre:['t_arcade2'],   name:'Arcade Endowment', desc:'+25% arcade rewards', apply:()=>{mods.arcadeReward*=1.25;}},
      {id:'t_arcade4',tier:5,rp:1200,pre:['t_arcade3'],  name:'Arcade Jackpot',   desc:'+25% arcade rewards', apply:()=>{mods.arcadeReward*=1.25;}}
    ]},
    {name:'Quantum', id:'quantum', items:[
      {id:'t_combo2', tier:1,rp:420,pre:['t_combo'],     name:'Combo Sustain',    desc:'Slower combo decay',   apply:()=>{state.combo.decay=Math.max(0.05,state.combo.decay*0.7);}},
      {id:'t_time',   tier:2,rp:700,pre:['t_click2'],    name:'Time Compression', desc:'Charge faster',        apply:()=>{state.charge.tMax=Math.max(1.2,state.charge.tMax*0.9);}},
      {id:'t_glob',   tier:3,rp:1400,pre:['t_over4'],    name:'Planck Shift',     desc:'+15% global',         apply:()=>{mults.global*=1.15;}},
      {id:'t_combo3', tier:4,rp:1600,pre:['t_combo2'],   name:'Combo Lock',       desc:'Higher combo cap',     apply:()=>{state.combo.max=1.0;}},
      {id:'t_glob2',  tier:5,rp:2100,pre:['t_glob'],     name:'Vacuum Symmetry',  desc:'+20% global',         apply:()=>{mults.global*=1.20;}},
      {id:'t_qtime2', tier:5,rp:1800,pre:['t_time'],     name:'Temporal Folding', desc:'Charge even faster',   apply:()=>{state.charge.tMax=Math.max(1.0,state.charge.tMax*0.85);}},
      {id:'t_combo4', tier:6,rp:2400,pre:['t_combo3'],   name:'Combo Anchor',     desc:'Cap + decay ↓',        apply:()=>{state.combo.max=1.2; state.combo.decay=Math.max(0.04,state.combo.decay*0.75);}}
    ]},
    {name:'Economy', id:'economy', items:[
      {id:'e_bulk',      tier:0,rp:180,pre:[],            name:'Bulk Logistics',      desc:'Module output +10%', apply:()=>{mults.modules*=1.10;}},
      {id:'e_vendor',    tier:1,rp:350,pre:['e_bulk'],    name:'Vendor Network',      desc:'Shop costs -6%',     apply:()=>{mods.costMult=(mods.costMult||1)*0.94;}},
      {id:'e_synergy',   tier:2,rp:520,pre:['e_bulk'],    name:'Synergy Matrices',    desc:'Module output +15%', apply:()=>{mults.modules*=1.15;}},
      {id:'e_broker',    tier:3,rp:850,pre:['e_vendor'],  name:'Dimensional Brokers', desc:'Shop costs -8%',     apply:()=>{mods.costMult=(mods.costMult||1)*0.92;}},
      {id:'e_overdrive', tier:3,rp:900,pre:['e_synergy'], name:'Overdrive Plants',    desc:'+10% global',       apply:()=>{mults.global*=1.10;}},
      {id:'e_network',   tier:4,rp:1200,pre:['e_broker'], name:'Parallel Supply',     desc:'Module output +20%', apply:()=>{mults.modules*=1.20;}}
    ]},
    {name:'Defense', id:'defense', items:[
      {id:'d_warn',     tier:0,rp:200,pre:[],           name:'Beam Early Warning', desc:'(placeholder effect)', apply:()=>{mods.beamWarn=(mods.beamWarn||1)*1.25;}},
      {id:'d_cushion',  tier:1,rp:300,pre:['d_warn'],   name:'Kinetic Cushion',    desc:'Arcade penalties -20%', apply:()=>{mods.damageShield=(mods.damageShield||1)*0.8;}},
      {id:'d_observer', tier:2,rp:520,pre:['d_warn'],   name:'Trajectory Observer',desc:'Gate wider + pulses last', apply:()=>{mods.gateZone*=1.05; mods.pulseLife*=1.1;}},
      {id:'d_reflect',  tier:3,rp:900,pre:['d_cushion'],name:'Reflective Mesh',    desc:'+10% global',          apply:()=>{mults.global*=1.10;}}
    ]}
  ];

  const TECH = TREES.flatMap(tr => tr.items.map(it => ({...it, tree: tr.id})));
  const SAVE_KEY=('quantum_forge_v7@'+(location.host||'local'));

  function ensureDefaults(){
    state.ui = state.ui || {drawerOpen:false,scale:1,sideRect:null,maxScroll:0,scrollDrag:{active:false,lastY:0,vy:0,tab:null},scrollVel:0};
    const byId={}; (state.modules||[]).forEach(m=>{byId[m.id]=m;});
    state.modules = MODULES.map(m => byId[m.id] ? {id:m.id,count:byId[m.id].count||0} : {id:m.id,count:0});
  }
  function save(){state.lastSave=Date.now();const data={...state,mults,mods};try{localStorage.setItem(SAVE_KEY,JSON.stringify(data));}catch{}}
  function load(){
    try{
      let raw=localStorage.getItem(SAVE_KEY);
      if(!raw){ ensureDefaults(); return; }
      const d=JSON.parse(raw);
      const keep=['bits','bitsTotal','lifetimeBits','rp','rpTotal','clickBase','clickMult','charge','critZone','combo','modules','upgrades','tech','achievements','ascend','settings','cheat','lastSave','tab','buyQtyIndex','researchCat','scroll','glitch','rift','particles','toast','arcade','clickArea','ui'];
      for(const k of keep){ if(k in d) state[k]=d[k]; }
      if(d.mults) Object.assign(mults,d.mults);
      if(d.mods) Object.assign(mods,d.mods);
      ensureDefaults();
      const secs=clamp((Date.now()-(d.lastSave||Date.now()))/1000,0,3600*8);
      const pps=totalPPS(); const off=pps*secs*0.75; if(off>0){ addBits(off); toast(`Offline +${fmt(off)} bits`); }
    }catch{ ensureDefaults(); }
  }
  load();
  document.addEventListener('visibilitychange',()=>{if(document.hidden)save();},{passive:true});
  window.addEventListener('beforeunload',()=>{try{save();}catch{}});

  function count(id){return state.modules[id]?.count||0;}
  function moduleCost(id,n){
    const m=MODULES[id],c=count(m.id); 
    const r=m.mult;
    const base=(m.base*mods.costMult)*(r**c);
    if(n===1) return base;
    return base*((r**n-1)/(r-1));
  }
  function moduleProd(id){const m=MODULES[id]; return (m.prod||0)*mults.modules*mults.global*(1+state.ascend.cores*0.1);}
  function totalPPS(){let v=0;for(const m of MODULES){v+=count(m.id)*moduleProd(m.id);}return v*(1+state.combo.v);}
  function rpPerSec(){ let rpv=0; for(const m of MODULES){ if(m.rp){ rpv += (m.rp||0)*count(m.id); } } return rpv*mods.rpGain; }

  function clickValueFromCharge(){
    const q=state.charge.t/state.charge.tMax; const curve=(q*q)*mods.clickCurve;
    return state.clickBase*state.clickMult*curve*(1+state.ascend.cores*0.1)*mults.global;
  }

  function canAfford(x){return state.bits>=x;}
  function maxAffordable(id){
    const m=MODULES[id];
    const r=m.mult;const c=count(id);
    const base=(m.base*mods.costMult)*(r**c); 
    if(state.bits<base) return 0; 
    const A=state.bits*(r-1)/base+1; 
    const n=Math.floor(Math.log(A)/Math.log(r)); 
    return Math.max(0,n);
  }
  function buyModule(id){const qty=BUY_QTY[state.buyQtyIndex]; let n=qty==='Max'?maxAffordable(id):qty; if(n<=0)return; const cost=moduleCost(id,n); if(!canAfford(cost))return; state.bits-=cost; state.modules[id].count+=n; beep(220+id*30,0.02,0.02);}
  function cycleBuyQty(d){state.buyQtyIndex=(state.buyQtyIndex+d+BUY_QTY.length)%BUY_QTY.length; toast(`Buy: ${BUY_QTY[state.buyQtyIndex]}`);}

  function addBits(v){if(!isFinite(v))return; state.bits+=v; state.bitsTotal+=v; state.lifetimeBits+=v;}
  function addRP(v){if(!isFinite(v))return; state.rp+=v; state.rpTotal+=v;}

  function hasTech(id){return state.tech.includes(id);}
  function techById(id){return TECH.find(t=>t.id===id);}
  function techAvailable(t){return !hasTech(t.id)&&t.pre.every(p=>hasTech(p));}
  function buyTech(t){if(!techAvailable(t)||state.rp<t.rp)return; state.rp-=t.rp; state.tech.push(t.id); t.apply(); toast(`Researched: ${t.name}`); beep(760,0.05,0.03);}

  // CORE GAIN: current bits only (not lifetime)
  function coreGain(){
    return Math.floor(Math.sqrt(state.bits / 1e6));
  }

  // Ascend resets research + multipliers
  function tryAscend(){
    const gain = coreGain();
    if (gain <= 0) { toast('Generate more Bits to ascend'); return; }

    state.ascend.cores += gain;
    state.ascend.best = Math.max(state.ascend.best, state.ascend.cores);

    state.bits = 0;
    state.bitsTotal = 0;
    state.clickBase = 1;
    state.clickMult = 1;
    state.modules = MODULES.map(m => ({id: m.id, count: 0}));
    state.upgrades = [];
    state.rp = 0;

    // reset research
    state.tech = [];
    // restore multipliers/modifiers defaults
    mults.global = 1; mults.modules = 1; mults.glitch = 1; mults.combo = 1;
    Object.assign(mods, {
      clickCurve: 1, rpGain: 1, arcadeReward: 1, riftHP: 1, gateZone: 1,
      pulseSize: 1, pulseLife: 1, costMult: 1, glitchRate: 1, riftReward: 1
    });
    // restore state influenced by tech
    state.charge = {active:false, t:0, tMax:1.6};
    state.critZone = {lo:0.92, hi:1.0, mult:3};
    state.combo = {v:0, max:0.5, decay:0.12};

    // misc reset
    state.glitch = {next:rand(18,40), life:0, x:0, y:0, active:false, value:0};

    toast(`Ascended: +${gain} core(s) → global x${(1 + state.ascend.cores*0.1).toFixed(2)}`);
    beep(880, 0.07, 0.03);
    save();
  }

  function updateGlitch(dt){
    const g=state.glitch;
    if(g.active){g.life-=dt; if(g.life<=0)g.active=false;}
    else{ g.next-=dt; if(g.next<=0){ g.active=true; g.life=10; g.x=rand(100,CANVAS.width-100); g.y=rand(120,CANVAS.height-160); g.value=(totalPPS()*rand(8,24)+clickValueFromCharge()*rand(20,60))*mults.glitch; g.next=rand(32,68)/mods.glitchRate;} }
  }
  function tryClickGlitch(px,py){
    const g=state.glitch; if(!g.active) return false;
    const d2=(px-g.x)**2+(py-g.y)**2; if(d2<=(28*DPR)**2){ addBits(g.value); g.active=false; particleBurst(g.x,g.y,18,'#ffd54a'); toast(`Glitch +${fmt(g.value)}`); beep(1200,0.06,0.04,'sawtooth'); return true; }
    return false;
  }

  function updateRift(dt){
    const r=state.rift;
    if(r.active){
      r.wobble+=dt;
      if(!r.closing&&r.open<1) r.open=Math.min(1,r.open+dt*1.8);
      if(r.closing){
        r.open=Math.max(0,r.open-dt*1.8);
        if(r.open<=0){r.active=false;r.closing=false;r.timer=rand(170,240);r.stars=[];}
      }
    }else{
      r.timer-=dt;
      if(r.timer<=0){
        r.active=true;r.open=0;r.closing=false;r.wobble=0;
        const pps=Math.max(1,totalPPS());
        r.hpMax=pps*rand(40,70)*mods.riftHP; r.hp=r.hpMax;
        r.bitsReward=pps*rand(80,160)*mods.riftReward;
        r.rpReward=Math.max(5,pps*0.02*rand(20,40))*mods.riftReward;
        r.prize=Math.random()<0.5?'bits':'rp';
        r.ttl=30; r.stars.length=0; for(let i=0;i<80;i++) r.stars.push({x:Math.random(),y:Math.random(),a:rand(0.5,1)});
        toast('A Rift tears reality! Spam click to seal it!');
      }
    }
  }
  function riftRect(){
    const UIS=state.ui.scale||1; const pad=16*DPR*UIS, headerH=64*DPR*UIS;
    const compact=(CANVAS.width/DPR)<980;
    const sidebarW=compact?(state.ui.drawerOpen?Math.min(320*DPR,CANVAS.width-2*pad):0):Math.max(340*DPR,CANVAS.width*0.30);
    const mainX=pad, mainY=pad*2+headerH; const mainW=CANVAS.width-sidebarW-pad*3; const mainH=CANVAS.height-mainY-pad;
    const yMid=mainY+mainH*0.45; const h=clamp(state.rift.open,0,1)*Math.max(60*DPR,mainH*0.25);
    return {x:mainX+12*DPR,yMid,w:mainW-24*DPR,h};
  }
  function tryClickRift(px,py){
    const r=state.rift; if(!r.active) return false; const area=riftRect();
    if(px>=area.x&&px<=area.x+area.w&&Math.abs(py-area.yMid)<=area.h/2){
      const dmg=Math.max(5,totalPPS()*0.8+10);
      r.hp=Math.max(0,r.hp-dmg);
      particleBurst(px,py,6,'#ff8fa3'); beep(980,0.02,0.02,'square');
      if(r.hp<=0&&!r.closing){
        r.closing=true;
        if(r.prize==='bits'){ addBits(r.bitsReward); toast(`Rift sealed! +${fmt(r.bitsReward)} bits`); }
        else { addRP(r.rpReward); toast(`Rift sealed! +${fmt(r.rpReward)} RP`); }
      }
      return true;
    }
    return false;
  }

  const clicks=[]; function addClick(x,y,w,h,onClick){clicks.push({x,y,w,h,onClick});} function hit(px,py,r){return px>=r.x&&px<=r.x+r.w&&py>=r.y&&py<=r.y+r.h;}
  function drawButton(x,y,w,h,label,on=true,accent=false){const r=10*DPR;CTX.save();CTX.fillStyle=on?(accent?'#2f3947':'#1a212b'):'#11161d';roundRect(x,y,w,h,r,true,false);CTX.fillStyle=on?'#e6eef6':'#7f8da0';CTX.font=`700 ${14*DPR}px Inter`;CTX.textAlign='center';CTX.textBaseline='middle';CTX.fillText(label,x+w/2,y+h/2);CTX.restore();}
  function drawBar(x,y,w,h,t,col='#4ade80'){CTX.fillStyle='#10151b';roundRect(x,y,w,h,h/2,true,false);CTX.fillStyle=col;roundRect(x,y,w*clamp(t,0,1),h,h/2,true,false);}
  function roundRect(x,y,w,h,r,fill,stroke){CTX.beginPath();CTX.moveTo(x+r,y);CTX.arcTo(x+w,y,x+w,y+h,r);CTX.arcTo(x+w,y+h,x,y+h,r);CTX.arcTo(x,y+h,x,y,r);CTX.arcTo(x,y,x+w,y,r);CTX.closePath();if(fill)CTX.fill();if(stroke)CTX.stroke();}
  function pill(x,y,txt){const fs=12*DPR,pad=6*DPR,w=measure(txt,fs,'700')*DPR+pad*2,h=20*DPR;CTX.fillStyle='#141a21';roundRect(x,y,w,h,999,true,false);CTX.fillStyle='#9fb0c6';CTX.font=`700 ${fs}px Inter`;CTX.textAlign='center';CTX.textBaseline='middle';CTX.fillText(txt,x+w/2,y+h/2);return{w,h};}
  function tooltip(x,y,lines){
    const fs=12*DPR; const pad=8*DPR;
    const w=Math.max(...lines.map(t=>measure(t,fs,'700')))*DPR + pad*2;
    const h=(fs+4*DPR)*lines.length + pad*2;
    let bx=x+14*DPR, by=y+14*DPR;
    if(bx+w>CANVAS.width-8*DPR) bx = x - w - 14*DPR;
    if(by+h>CANVAS.height-8*DPR) by = y - h - 14*DPR;
    CTX.fillStyle='#0c1117'; roundRect(bx,by,w,h,8*DPR,true,false);
    CTX.strokeStyle='#304256'; CTX.lineWidth=1*DPR; CTX.stroke();
    CTX.fillStyle='#e6eef6'; CTX.textAlign='left'; CTX.textBaseline='top'; CTX.font=`700 ${fs}px Inter`;
    let ty=by+pad; for(const t of lines){CTX.fillText(t,bx+pad,ty); ty+=fs+4*DPR;}
  }
  function toast(msg){state.toast.push({msg,t:2.6});}

  function particleBurst(x,y,n=12,color='#9be5ff'){for(let i=0;i<n;i++){state.particles.push({x,y,vx:rand(-120,120),vy:rand(-180,-40),life:rand(0.4,0.9),age:0,color});}}
  function updateParticles(dt){for(let i=state.particles.length-1;i>=0;i--){const p=state.particles[i];p.age+=dt;p.x+=p.vx*dt;p.y+=p.vy*dt;p.vy+=220*dt;if(p.age>p.life)state.particles.splice(i,1);}}
  function drawParticles(){for(const p of state.particles){const t=1-p.age/p.life;CTX.globalAlpha=Math.max(0,t);CTX.fillStyle=p.color;CTX.fillRect(p.x,p.y,3*DPR,3*DPR);CTX.globalAlpha=1;}}
  function updateToasts(dt){for(let i=state.toast.length-1;i>=0;i--){const t=state.toast[i];t.t-=dt;if(t.t<=0)state.toast.splice(i,1);}}
  function drawToasts(){const fs=12*DPR;CTX.font=`700 ${fs}px Inter`;CTX.textAlign='center';let y=20*DPR;for(const t of state.toast){CTX.fillStyle='#0f141a';const w=measure(t.msg,fs,'700')*DPR+26*DPR;const h=24*DPR;const x=CANVAS.width/2-w/2;roundRect(x,y,w,h,10*DPR,true,false);CTX.fillStyle='#e6eef6';CTX.fillText(t.msg,CANVAS.width/2,y+h/2);y+=h+8*DPR;}}

  function updateCharge(dt){
    const area=state.clickArea; if(!area) return;
    const inside=((input.mx-area.cx)**2+(input.my-area.cy)**2)<=area.R*area.R;
    if(input.down&&!prevDown&&inside){state.charge.active=true;}
    if(state.charge.active){
      if(input.down){
        state.charge.t=clamp(state.charge.t+dt*(1+(hasTech('t_over1')?0.15:0)),0,state.charge.tMax);
      }else{
        const base=clickValueFromCharge();
        const q=state.charge.t/state.charge.tMax; const inCrit=q>=state.critZone.lo&&q<=state.critZone.hi; const val=base*(inCrit?state.critZone.mult:1);
        addBits(val); particleBurst(input.mx,input.my,inCrit?18:10,inCrit?'#9be5ff':'#c7d2fe'); beep(inCrit?820:520,inCrit?0.06:0.03,0.03);
        state.combo.v=clamp(state.combo.v+q*0.12,0,state.combo.max);
        addRP(q*0.4*mods.rpGain);
        state.charge.active=false; state.charge.t=0;
      }
    }
    if(!input.down){state.charge.active=false;}
  }

  // ===== Arcade (Pulse / Gate / Meteor only) =====
  function startPulseRush(){
    state.arcade.active=true; state.arcade.mode='pulse'; state.arcade.t=25; state.arcade.score=0; state.arcade.pulses=[];
    state.arcade.pulse={spawn:0.65,life:2.4*mods.pulseLife,rMin:22*mods.pulseSize,rMax:42*mods.pulseSize,maxOnScreen:8};
    toast('Pulse Rush: click the orbs!');
  }
  function startGate(){
    state.arcade.active=true; state.arcade.mode='gate'; state.arcade.t=30; state.arcade.score=0;
    const w=0.10*mods.gateZone; state.arcade.gate={x:0.0,v:0.9,zone:[0.5-w/2,0.5+w/2],tries:8}; toast('Timing Gate: press Space or click');
  }
  function startMeteor(){
    state.arcade.active=true; state.arcade.mode='meteor'; state.arcade.t=28; state.arcade.score=0;
    const speed=300*DPR;
    state.arcade.meteor={
      px:CANVAS.width/2, py:CANVAS.height*0.65, r:14*DPR,
      rocks:[], comets:[], mines:[], shards:[], beams:[], stars:[],
      spawn:{rock:7.5, comet:1.0, mine:1.2, beam:0.45, star:0.55},
      speed
    };
    toast('Meteor Dodge+: dodge meteors, shards & lasers.');
  }

  function updateArcade(dt){
    if(!state.arcade.active) return;
    const A=state.arcade; A.t-=dt; if(A.t<=0){endArcade();return;}

    if(A.mode==='pulse'){
      const conf=A.pulse; if(A.pulses.length<conf.maxOnScreen&&Math.random()<dt*conf.spawn){const life=conf.life;A.pulses.push({x:rand(120,CANVAS.width-120),y:rand(160,CANVAS.height-160),life,max:life});}
      for(let i=A.pulses.length-1;i>=0;i--){const p=A.pulses[i];p.life-=dt;if(p.life<=0)A.pulses.splice(i,1);}

    }else if(A.mode==='gate'){
      const g=A.gate; g.x+=g.v*dt; if(g.x<0){g.x=0;g.v=Math.abs(g.v);} if(g.x>1){g.x=1;g.v=-Math.abs(g.v);}

    }else if(A.mode==='meteor'){
      const M=A.meteor; M.px=input.mx; M.py=input.my; A.score+=dt*3.0;
      if(Math.random()<dt*M.spawn.rock) M.rocks.push({x:rand(30,CANVAS.width-30),y:-30*DPR,r:rand(22,52)*DPR,vy:rand(1.2,1.8)*M.speed});
      if(Math.random()<dt*M.spawn.comet){
        const x=rand(20,CANVAS.width-20), y=-40*DPR, vx=0, vy=rand(1.05,1.35)*M.speed;
        M.comets.push({x,y,r:rand(16,26)*DPR,vx,vy,homing:0.006,drift:rand(-0.3,0.3)});
      }
      if(Math.random()<dt*M.spawn.mine) M.mines.push({x:rand(40,CANVAS.width-40),y:-20*DPR,r:16*DPR,vy:rand(0.8,1.1)*M.speed,t:2.4});
      if(Math.random()<dt*M.spawn.beam) spawnBeam(M);
      if(Math.random()<dt*M.spawn.star) M.stars.push({x:rand(40,CANVAS.width-40),y:-10*DPR,r:8*DPR,vy:rand(0.9,1.2)*M.speed});

      for(let i=M.rocks.length-1;i>=0;i--){const k=M.rocks[i];k.y+=k.vy*dt;if(k.y>CANVAS.height+80*DPR)M.rocks.splice(i,1);}
      for(let i=M.comets.length-1;i>=0;i--){const c=M.comets[i]; c.x+=c.vx*dt; c.y+=c.vy*dt; if(c.y>CANVAS.height+120*DPR) M.comets.splice(i,1);}
      for(let i=M.mines.length-1;i>=0;i--){const m=M.mines[i]; m.y+=m.vy*dt; m.t-=dt; if(m.t<=0||m.y>CANVAS.height-40*DPR){ const N=10; const sp=rand(220,320)*DPR; for(let j=0;j<N;j++){const a=(Math.PI*2)*j/N + rand(-0.2,0.2); M.shards.push({x:m.x,y:m.y,r:6*DPR,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:1.6});} particleBurst(m.x,m.y,12,'#ffcf88'); M.mines.splice(i,1); beep(520,0.05,0.03,'square'); } }
      for(let i=M.shards.length-1;i>=0;i--){const s=M.shards[i]; s.x+=s.vx*dt; s.y+=s.vy*dt; s.life-=dt; if(s.life<=0) M.shards.splice(i,1);}
      for(let i=M.beams.length-1;i>=0;i--){const b=M.beams[i]; b.t-=dt; if(b.phase==='warn'&&b.t<=0){b.phase='fire'; b.t=b.fire;} else if(b.phase==='fire'&&b.t<=0){M.beams.splice(i,1);}}
      for(let i=M.stars.length-1;i>=0;i--){const k=M.stars[i];k.y+=k.vy*dt;if(k.y>CANVAS.height+30*DPR)M.stars.splice(i,1);}
      const pr=M.r; function hitCircle(cx,cy,cr){const d2=(cx-M.px)**2+(cy-M.py)**2; return d2<=(cr+pr)**2; }
      function penalize(amount=3){ A.score=Math.max(0,A.score-amount); beep(260,0.04,0.03,'sine'); particleBurst(M.px,M.py,8,'#ff9aa2'); }
      for(let i=M.rocks.length-1;i>=0;i--){const k=M.rocks[i]; if(hitCircle(k.x,k.y,k.r)){ penalize(3); M.rocks.splice(i,1);}}
      for(let i=M.comets.length-1;i>=0;i--){const k=M.comets[i]; if(hitCircle(k.x,k.y,k.r)){ penalize(3); M.comets.splice(i,1);}}
      for(let i=M.mines.length-1;i>=0;i--){const k=M.mines[i]; if(hitCircle(k.x,k.y,k.r*1.1)){ penalize(4); k.t=0; }}
      for(let i=M.shards.length-1;i>=0;i--){const k=M.shards[i]; if(hitCircle(k.x,k.y,k.r)){ penalize(2.5); M.shards.splice(i,1);}}
      for(const b of M.beams){ if(b.phase!=='fire') continue; if(b.dir==='h'){ const y=b.pos, half=b.th/2; if(M.py>y-half && M.py<y+half){ penalize(6); } } else { const x=b.pos, half=b.th/2; if(M.px>x-half && M.px<x+half){ penalize(6); } } }
      for(let i=M.stars.length-1;i>=0;i--){const k=M.stars[i]; if(hitCircle(k.x,k.y,k.r)){ A.score+=3; addRP(0.5*mods.rpGain); beep(900,0.03,0.02,'triangle'); particleBurst(k.x,k.y,6,'#a7f3d0'); M.stars.splice(i,1);}}
    }
  }
  function spawnBeam(M){
    const horizontal=Math.random()<0.5;
    if(horizontal){
      const y=rand(120*DPR, CANVAS.height-120*DPR);
      M.beams.push({dir:'h',pos:y,phase:'warn',t:0.75,fire:1.00,th:26*DPR});
    }else{
      const x=rand(80*DPR, CANVAS.width-80*DPR);
      M.beams.push({dir:'v',pos:x,phase:'warn',t:0.75,fire:1.00,th:26*DPR});
    }
  }
  function endArcade(){
    if(!state.arcade.active) return;
    const s=Math.max(0,Math.floor(state.arcade.score)); const mode=state.arcade.mode; state.arcade.active=false;
    let bits=0,rp=0;
    if(mode==='pulse'){bits=s*3;rp=s*0.3;}
    else if(mode==='gate'){bits=s*8;rp=s*0.6;}
    else if(mode==='meteor'){bits=s*6;rp=s*0.45;}
    bits*=mods.arcadeReward; rp*=mods.arcadeReward;
    if(bits||rp){addBits(bits);addRP(rp);toast(`Arcade reward: +${fmt(bits)} bits, +${fmt(rp)} RP`);}
  }
  function drawArcade(){
    if(!state.arcade.active) return;
    const A=state.arcade;
    CTX.globalAlpha=0.85;CTX.fillStyle='#000';CTX.fillRect(0,0,CANVAS.width,CANVAS.height);CTX.globalAlpha=1;
    const modeTitle={pulse:'Pulse Rush',gate:'Timing Gate',meteor:'Meteor Dodge+'}[A.mode]||'Arcade';
    CTX.fillStyle='#e6eef6';CTX.font=`800 ${18*DPR}px Inter`;CTX.textAlign='center';CTX.fillText(`${modeTitle} — ${A.t.toFixed(1)}s`,CANVAS.width/2,60*DPR);

    if(A.mode==='pulse'){
      const conf=A.pulse; for(const p of A.pulses){const t=p.life/p.max; const r=lerp(conf.rMin*DPR,conf.rMax*DPR,t); CTX.globalAlpha=Math.max(0.2,t); CTX.fillStyle='#8be9fd'; CTX.beginPath(); CTX.arc(p.x,p.y,r,0,Math.PI*2); CTX.fill(); CTX.globalAlpha=1;}
      CTX.fillStyle='#9fb0c6';CTX.font=`700 ${14*DPR}px Inter`;CTX.fillText(`Score: ${Math.floor(A.score)}`,CANVAS.width/2,90*DPR);

    }else if(A.mode==='gate'){
      const cx=CANVAS.width/2,y=CANVAS.height/2,W=520*DPR,H=22*DPR; CTX.fillStyle='#121821'; roundRect(cx-W/2,y-H/2,W,H,10*DPR,true,false);
      const [zl,zh]=A.gate.zone; CTX.fillStyle='#284b63'; roundRect(cx-W/2+W*zl,y-H/2,W*(zh-zl),H,10*DPR,true,false);
      const mx=cx-W/2+W*A.gate.x; CTX.fillStyle='#e6eef6'; roundRect(mx-5*DPR,y-10*DPR,10*DPR,20*DPR,3*DPR,true,false);
      CTX.fillStyle='#9fb0c6';CTX.font=`700 ${14*DPR}px Inter`; CTX.fillText(`Tries: ${A.gate.tries}  Score: ${A.score}`,cx,y+40*DPR); CTX.fillText(`Press Space OR Click the bar`,cx,y+62*DPR);

    }else if(A.mode==='meteor'){
      const M=A.meteor;
      for(const b of M.beams){
        if(b.phase==='warn'){
          CTX.globalAlpha=0.5+0.5*Math.sin(performance.now()/120);
          CTX.fillStyle='#314256';
          if(b.dir==='h') roundRect(0,b.pos-3*DPR,CANVAS.width,6*DPR,3*DPR,true,false);
          else roundRect(b.pos-3*DPR,0,6*DPR,CANVAS.height,3*DPR,true,false);
          CTX.globalAlpha=1;
        }else{
          CTX.globalAlpha=0.9;
          CTX.fillStyle='#c33';
          if(b.dir==='h') roundRect(0,b.pos-b.th/2,CANVAS.width,b.th,6*DPR,true,false);
          else roundRect(b.pos-b.th/2,0,b.th,CANVAS.height,6*DPR,true,false);
          CTX.globalAlpha=1;
        }
      }
      for(const k of M.rocks){CTX.fillStyle='#394553';CTX.beginPath();CTX.arc(k.x,k.y,k.r,0,Math.PI*2);CTX.fill();}
      for(const c of M.comets){CTX.fillStyle='#b8d7ff';CTX.beginPath();CTX.arc(c.x,c.y,c.r,0,Math.PI*2);CTX.fill();}
      for(const m of M.mines){CTX.fillStyle='#2d3744';CTX.beginPath();CTX.arc(m.x,m.y,m.r,0,Math.PI*2);CTX.fill();}
      for(const s of M.shards){CTX.fillStyle='#ffb38a'; CTX.beginPath(); CTX.arc(s.x,s.y,s.r,0,Math.PI*2); CTX.fill();}
      for(const s of M.stars){CTX.fillStyle='#9be7d7';CTX.beginPath();CTX.arc(s.x,s.y,s.r,0,Math.PI*2);CTX.fill();}
      CTX.fillStyle='#e6eef6';CTX.beginPath();CTX.arc(M.px,M.py,M.r,0,Math.PI*2);CTX.fill();
      CTX.fillStyle='#9fb0c6';CTX.font=`700 ${14*DPR}px Inter`;CTX.fillText(`Score: ${Math.floor(A.score)}`,CANVAS.width/2,90*DPR);
    }
  }

  function drawResearchList(tree){
    const items = tree.items.slice().sort((a,b)=> (a.tier-b.tier) || a.rp-b.rp );
    const listX=state.ui.sideRect.x, listY=state.ui.sideRect.y, listW=state.ui.sideRect.w;
    let y=listY - (state.scroll[state.tab]||0) + 44*DPR; // push below category tabs

    // category tabs
    const cats=TREES.map(t=>t.name);
    const tabW = Math.max(88*DPR, (listW-20*DPR)/cats.length);
    let tx=listX+10*DPR, ty=listY+6*DPR, th=28*DPR;
    for(let i=0;i<cats.length;i++){
      const active=(i===state.researchCat);
      CTX.fillStyle=active?'#1a222b':'#0f141a'; roundRect(tx,ty,tabW,th,8*DPR,true,false);
      CTX.fillStyle=active?'#e2ebf5':'#9fb0c6'; CTX.font=`700 ${11*DPR}px Inter`; CTX.textAlign='center'; CTX.textBaseline='middle';
      CTX.fillText(cats[i],tx+tabW/2,ty+th/2);
      addClick(tx,ty,tabW,th,()=>{ state.researchCat=i; state.scroll.Research=0; });
      tx+=tabW+6*DPR;
    }

    for(const t of items){
      const rowH=56*DPR; CTX.fillStyle='#121821'; roundRect(listX+10*DPR,y,listW-20*DPR,rowH,10*DPR,true,false);
      const owned=hasTech(t.id); const can=state.rp>=t.rp && techAvailable(t);
      CTX.fillStyle=owned?'#c8f7da':'#e6eef6'; CTX.font=`700 ${14*DPR}px Inter`; CTX.textAlign='left'; CTX.textBaseline='top';
      CTX.fillText(`${t.name} — ${t.rp} RP`,listX+22*DPR,y+10*DPR);
      CTX.fillStyle='#9fb0c6'; CTX.font=`600 ${12*DPR}px Inter`; CTX.fillText(t.desc,listX+22*DPR,y+28*DPR);
      const bw=96*DPR,bh=28*DPR; const bx=listX+listW-bw-22*DPR, by=y+rowH-bh-12*DPR;
      drawButton(bx,by,bw,bh, owned?'Owned':'Research', can, true);
      if(can) addClick(bx,by,bw,bh,()=>buyTech(t));
      y+=rowH+8*DPR;
    }
    // set max scroll
    const listH=state.ui.sideRect.h;
    state.ui.maxScroll=Math.max(0,(y-(listY+listH)));
  }

  // ===== Cheats =====
  function unlockCheats(){ 
    if(state.cheat.unlocked) return;
    state.cheat.unlocked = true; 
    toast('Dev menu unlocked');
    beep(1200,0.05,0.03,'square');
    save();
  }
  function cheatAddBits(n){ addBits(n); toast(`+${fmt(n)} bits`); }
  function cheatAddRP(n){ addRP(n); toast(`+${fmt(n)} RP`); }
  function cheatAddCores(n){
    state.ascend.cores = Math.max(0, (state.ascend.cores||0) + n);
    state.ascend.best  = Math.max(state.ascend.best, state.ascend.cores);
    toast(`Cores: ${state.ascend.cores}`);
  }
  function cheatToggleX10(){
    if(!state.cheat.x10){ mults.global *= 10; state.cheat.x10 = true; toast('Global x10 ON'); }
    else { mults.global /= 10; state.cheat.x10 = false; toast('Global x10 OFF'); }
  }
  function cheatUnlockAll(){
    for(const t of TECH){ if(!hasTech(t.id)){ state.tech.push(t.id); t.apply(); } }
    toast('All research unlocked');
  }
  function cheatSpawnRift(){ if(!state.rift.active){ state.rift.timer = 0; } }
  function cheatMaxModules(cnt=100){
    for(const m of MODULES){ state.modules[m.id].count = cnt; }
    toast(`All modules set to ${cnt}`);
  }

  function gateStop(){
    const A=state.arcade; if(!A.active||A.mode!=='gate'||A.gate.tries<=0) return; const g=A.gate; A.gate.tries--;
    const inside=(g.x>=g.zone[0]&&g.x<=g.zone[1]);
    if(inside){A.score++;const mid=(g.zone[0]+g.zone[1])/2;if(Math.abs(g.x-mid)<=(g.zone[1]-g.zone[0])*0.15){A.score++;toast('Perfect! +Bonus');}addRP(1.2*mods.rpGain);addBits(8);beep(880,0.05,0.02,'sine');}
    else{beep(260,0.05,0.02,'sine');}
    if(A.gate.tries<=0) endArcade();
  }

  function update(dt){
    addBits(totalPPS()*dt); addRP(rpPerSec()*dt);
    state.combo.v=clamp(state.combo.v-state.combo.decay*dt,0,state.combo.max);
    updateGlitch(dt); updateRift(dt); updateArcade(dt); updateCharge(dt); updateParticles(dt); updateToasts(dt);
  }

  function draw(dt){
    clicks.length=0; CTX.clearRect(0,0,CANVAS.width,CANVAS.height);
    const g=CTX.createLinearGradient(0,0,0,CANVAS.height); g.addColorStop(0,'#0a0e13'); g.addColorStop(1,'#0a0e13'); CTX.fillStyle=g; CTX.fillRect(0,0,CANVAS.width,CANVAS.height);

    const UIS=clamp(Math.min(CANVAS.width/(1280*DPR),CANVAS.height/(720*DPR)),0.8,1.15);
    state.ui.scale=UIS;
    const pad=16*DPR*UIS, headerH=64*DPR*UIS; const compact=(CANVAS.width/DPR)<980;
    let sidebarW=compact?(state.ui.drawerOpen?Math.min(320*DPR,CANVAS.width-2*pad):0):Math.max(340*DPR,CANVAS.width*0.30);

    CTX.fillStyle='#0f1318'; roundRect(pad,pad,CANVAS.width-pad*2,headerH,14*DPR,true,false);
    CTX.fillStyle='#e6eef6'; CTX.font=`800 ${20*DPR*state.ui.scale}px Inter`; CTX.textAlign='left'; CTX.textBaseline='middle'; CTX.fillText('Quantum Forge',pad*2,pad+headerH/2);
    let xr=CANVAS.width-pad*2-100*DPR; pill(xr,pad+headerH/2-10*DPR,`Buy: ${BUY_QTY[state.buyQtyIndex]}`); addClick(xr,pad+headerH/2-10*DPR,100*DPR,20*DPR,()=>cycleBuyQty(+1));
    xr-=150*DPR; pill(xr,pad+headerH/2-10*DPR,`Cores: ${fmt(state.ascend.cores)} (x${(1+state.ascend.cores*0.1).toFixed(2)})`);
    if(compact){
      const bw=36*DPR,bh=32*DPR; const bx=CANVAS.width-pad-bw, by=pad+headerH/2-bh/2;
      drawButton(bx,by,bw,bh,state.ui.drawerOpen?'✕':'≡',true,true); addClick(bx,by,bw,bh,()=>{state.ui.drawerOpen=!state.ui.drawerOpen;});
    }

    const mainX=pad, mainY=pad*2+headerH; const mainW=CANVAS.width-sidebarW-pad*3; const mainH=CANVAS.height-mainY-pad;
    const sideX=CANVAS.width-sidebarW-pad, sideY=mainY, sideH=mainH;

    CTX.fillStyle='#0f141a'; roundRect(mainX,mainY,mainW,mainH,16*DPR,true,false);

    (function(){
      const padHUD=10*DPR*UIS, f1=(16*UIS)*DPR, f2=(12*UIS)*DPR;
      const l1=`Bits: ${fmt(state.bits)}`, l2=`PPS: ${fmt(totalPPS())}   RP: ${fmt(state.rp)}`;
      CTX.font=`800 ${f1}px Inter`; const w1=CTX.measureText(l1).width; CTX.font=`700 ${f2}px Inter`; const w2=CTX.measureText(l2).width;
      const w=Math.max(w1,w2)+padHUD*2, h=f1+f2+padHUD*3, bx=mainX+(mainW-w)/2, by=mainY+8*DPR;
      CTX.fillStyle='#0b1117'; roundRect(bx,by,w,h,10*DPR,true,false);
      CTX.fillStyle='#e6eef6'; CTX.font=`800 ${f1}px Inter`; CTX.textAlign='center'; CTX.textBaseline='top'; CTX.fillText(l1,bx+w/2,by+padHUD*0.8);
      CTX.fillStyle='#b6c6da'; CTX.font=`700 ${f2}px Inter`; CTX.fillText(l2,bx+w/2,by+padHUD*0.8+f1+6*DPR);
    })();

    const cx=mainX+mainW*0.5, cy=mainY+mainH*(compact?0.60:0.58); const R=Math.min(mainW,mainH)*(compact?0.28:0.32);
    state.clickArea={cx,cy,R};
    CTX.save(); CTX.shadowBlur=36*DPR; CTX.shadowColor='#213141'; CTX.fillStyle='#16202b'; CTX.beginPath(); CTX.arc(cx,cy,R,0,Math.PI*2); CTX.fill(); CTX.restore();
    const q=state.charge.t/state.charge.tMax; CTX.lineWidth=8*DPR; CTX.strokeStyle='#2d4156'; CTX.beginPath(); CTX.arc(cx,cy,R-14*DPR,-Math.PI/2,-Math.PI/2+Math.PI*2*q); CTX.stroke();
    const a1=-Math.PI/2+Math.PI*2*state.critZone.lo, a2=-Math.PI/2+Math.PI*2*state.critZone.hi; CTX.strokeStyle='#86e7ff'; CTX.lineWidth=6*DPR; CTX.beginPath(); CTX.arc(cx,cy,R-18*DPR,a1,a2); CTX.stroke();
    CTX.fillStyle='#e6eef6'; CTX.font=`800 ${22*DPR}px Inter`; CTX.textAlign='center'; CTX.textBaseline='middle'; CTX.fillText(state.charge.active?'RELEASE':'HOLD',cx,cy);

    if(state.glitch.active){const t=(Math.sin(performance.now()/180)+1)/2;CTX.save();CTX.translate(state.glitch.x,state.glitch.y);CTX.rotate(t*0.3);CTX.fillStyle='#ffd54a';CTX.beginPath();CTX.arc(0,0,16*DPR,0,Math.PI*2);CTX.fill();CTX.fillStyle='#7a5600';CTX.beginPath();CTX.arc(-5*DPR,-2*DPR,2.5*DPR,0,Math.PI*2);CTX.fill();CTX.restore();addClick(state.glitch.x-18*DPR,state.glitch.y-18*DPR,36*DPR,36*DPR,(px,py)=>{tryClickGlitch(px,py);});}

    if(state.rift.active){
      const r=state.rift, rect=riftRect(), x=rect.x, w=rect.w, yMid=rect.yMid, h=rect.h;
      CTX.save(); CTX.globalAlpha=0.5*r.open; CTX.fillStyle='#000'; CTX.fillRect(0,0,CANVAS.width,CANVAS.height); CTX.globalAlpha=1;
      CTX.beginPath(); const segs=16, amp=8*DPR*r.open; let xx,yy;
      CTX.moveTo(x,yMid-h/2);
      for(let i=1;i<=segs;i++){const t=i/segs;xx=x+w*t;yy=yMid-h/2+Math.sin((t*10+r.wobble*2))*amp;CTX.lineTo(xx,yy);}
      for(let i=segs;i>=0;i--){const t=i/segs;xx=x+w*t;yy=yMid+h/2+Math.sin((t*10+r.wobble*2+Math.PI))*amp;CTX.lineTo(xx,yy);}
      CTX.closePath(); CTX.fillStyle='#0a0b12'; CTX.fill();
      for(const s of r.stars){const sx=x+s.x*w, sy=yMid-h/2+s.y*h; CTX.globalAlpha=s.a; CTX.fillStyle='#8dd3ff'; CTX.fillRect(sx,sy,2*DPR,2*DPR);} CTX.globalAlpha=1;
      CTX.strokeStyle='#1f2a3a'; CTX.lineWidth=2*DPR; CTX.stroke();
      CTX.fillStyle='#e6eef6'; CTX.font=`800 ${16*DPR}px Inter`; CTX.textAlign='center'; CTX.fillText('RIFT! SPAM-CLICK!',x+w/2,yMid-h/2-28*DPR);
      const barW=Math.min(w*0.7,520*DPR), barH=16*DPR, bx=x+(w-barW)/2, by=yMid+h/2+12*DPR; drawBar(bx,by,barW,barH,1-r.hp/r.hpMax,'#ef4444');
      CTX.fillStyle='#9fb0c6'; CTX.font=`700 ${12*DPR}px Inter`; const prizeTxt=r.prize==='bits'?`Reward: ${fmt(r.bitsReward)} bits`:`Reward: ${fmt(r.rpReward)} RP`; CTX.fillText(prizeTxt,x+w/2,by+barH+16*DPR);
      CTX.restore();
    }

    if(sidebarW>0){
      CTX.fillStyle='#0f141a'; roundRect(sideX,sideY,sidebarW,sideH,16*DPR,true,false);
      const tabs=['Forge','Shop','Research','Arcade','Achievements','Stats','Ascend','Settings'];
      if(state.cheat.unlocked) tabs.push('Cheats');
      const tabH=40*DPR; let tx=sideX; const tw=sidebarW/tabs.length; const tabFs=tw<90*DPR?11*DPR:13*DPR;
      for(const tname of tabs){
        const active=state.tab===tname;
        CTX.fillStyle=active?'#1a222b':'#0f141a'; roundRect(tx,sideY,tw,tabH,10*DPR,true,false);
        CTX.fillStyle=active?'#e2ebf5':'#9fb0c6'; CTX.font=`700 ${tabFs}px Inter`; CTX.textAlign='center'; CTX.textBaseline='middle'; CTX.fillText(tname,tx+tw/2,sideY+tabH/2);
        addClick(tx,sideY,tw,tabH,()=>{state.tab=tname; state.ui.scrollVel=0;});
        tx+=tw;
      }

      const listX=sideX+10*DPR, listY=sideY+tabH+10*DPR, listW=sidebarW-20*DPR, listH=sideH-tabH-20*DPR;
      CTX.save(); CTX.beginPath(); CTX.rect(listX,listY,listW,listH); CTX.clip();
      state.ui.sideRect={x:listX,y:listY,w:listW,h:listH};
      let sOff=state.scroll[state.tab]||0; let y=listY - sOff;

      if(state.tab==='Forge'){
        const rowH=70*DPR; CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,10*DPR,true,false);
        CTX.fillStyle='#9fb0c6'; CTX.font=`600 ${12*DPR}px Inter`; CTX.textAlign='left'; CTX.textBaseline='top';
        CTX.fillText(`Combo: ${(state.combo.v*100).toFixed(0)}% (decay ${Math.round(state.combo.decay*100)}%/s)`,listX+12*DPR,y+12*DPR);
        CTX.fillText(`PPS (after combo): ${fmt(totalPPS())} | RP/s: ${fmt(rpPerSec())}`,listX+12*DPR,y+32*DPR);
        y+=rowH+10*DPR;
        const rowH2=80*DPR; CTX.fillStyle='#0f141a'; roundRect(listX,y,listW,rowH2,10*DPR,true,false);
        CTX.fillStyle='#b6c6da'; CTX.font=`600 ${12*DPR}px Inter`;
        CTX.fillText('Hold inside the core to charge. Release in the highlighted arc for critical payout. Play Arcade for bursts & RP.',listX+12*DPR,y+14*DPR);
        y+=rowH2+10*DPR;
      }

      if(state.tab==='Shop'){
        const us=state.ui.scale||1, isNarrow=listW<460*DPR*us, baseRowH=(isNarrow?92:70)*DPR*us;
        for(const m of MODULES){
          const n=count(m.id), qty=BUY_QTY[state.buyQtyIndex], nToBuy=qty==='Max'?maxAffordable(m.id):qty;
          const cost=moduleCost(m.id,nToBuy), afford=nToBuy>0&&state.bits>=cost, rowH=baseRowH;
          CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,10*DPR*us,true,false);
          const nameX=listX+12*DPR*us, nameY=y+10*DPR*us;
          CTX.fillStyle='#e6eef6'; CTX.font=`800 ${15*DPR*us}px Inter`; CTX.textAlign='left'; CTX.textBaseline='top'; CTX.fillText(m.name,nameX,nameY);
          const label=qty==='Max'?`Buy ${nToBuy}`:`Buy x${nToBuy}`;
          const fsBtn=14*DPR*us; CTX.font=`700 ${fsBtn}px Inter`;
          const bw=Math.max(100*DPR*us,CTX.measureText(label).width+28*DPR*us), bh=32*DPR*us;
          const bx=listX+listW-bw-12*DPR*us, by=y+rowH-bh-10*DPR*us;
          if(isNarrow){
            CTX.fillStyle=afford?'#b8f0c2':'#93a6bf'; CTX.font=`800 ${13*DPR*us}px Inter`; CTX.textAlign='left';
            CTX.fillText(`Cost: ${fmt(cost)}`,nameX,nameY+20*DPR*us);
            CTX.fillStyle='#9fb0c6'; CTX.font=`600 ${12*DPR*us}px Inter`;
            const rpLine = m.rp?` • RP: ${m.rp}/s`:'';
            CTX.fillText(`Owned: ${n} • +${fmt(moduleProd(m.id))}/s${rpLine}`,nameX,nameY+38*DPR*us);
          }else{
            CTX.fillStyle='#9fb0c6'; CTX.font=`600 ${12*DPR*us}px Inter`; CTX.textAlign='left';
            const rpLine = m.rp?` • RP: ${m.rp}/s`:'';
            CTX.fillText(`Owned: ${n} • +${fmt(moduleProd(m.id))}/s${rpLine}`,nameX,nameY+22*DPR*us);
            CTX.fillStyle=afford?'#b8f0c2':'#93a6bf'; CTX.font=`800 ${14*DPR*us}px Inter`; CTX.textAlign='right';
            CTX.fillText(`Cost: ${fmt(cost)}`,bx-12*DPR*us,nameY+2*DPR*us);
          }
          drawButton(bx,by,bw,bh,label,afford,true); addClick(bx,by,bw,bh,()=>buyModule(m.id));
          y+=rowH+10*DPR*us;
        }
      }

      if(state.tab==='Research'){
        drawResearchList(TREES[state.researchCat]);
      }

      if(state.tab==='Arcade'){
        const us=state.ui.scale||1, isNarrow=listW<500*DPR*us;
        function row(title,desc,onClick){
          const fs=14*DPR*us; CTX.font=`700 ${fs}px Inter`; const btnTextW=CTX.measureText(title).width;
          const bw=Math.max(160*DPR*us,Math.min(260*DPR*us,btnTextW+28*DPR*us)), bh=36*DPR*us;
          const rowH=isNarrow?(bh+32*DPR*us+22*DPR*us):56*DPR*us;
          CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,10*DPR*us,true,false);
          const bx=listX+12*DPR*us, by=y+10*DPR*us; drawButton(bx,by,bw,bh,title,true,true); addClick(bx,by,bw,bh,onClick);
          CTX.fillStyle='#9fb0c6'; CTX.font=`600 ${12*DPR*us}px Inter`; CTX.textAlign='left';
          if(isNarrow) CTX.fillText(desc,bx,by+bh+16*DPR*us); else {const dx=bx+bw+14*DPR*us, dy=y+rowH/2+4*DPR*us; CTX.textBaseline='middle'; CTX.fillText(desc,dx,dy);}
          y+=rowH+10*DPR*us;
        }
        row('Start Pulse Rush','Rapid orbs spawn. Click them for Bits and RP.',()=>startPulseRush());
        row('Start Timing Gate','Stop the marker in the zone with Space/click.',()=>startGate());
        row('Start Meteor Dodge+','Dodge meteors, shards & lasers.',()=>startMeteor());
      }

      if(state.tab==='Achievements'){
        const rows=[['First Pulse','Release a charged pulse once',state.lifetimeBits>0],['Collector','Own 30 modules total',state.modules.reduce((a,b)=>a+(b.count||0),0)>=30],['Researcher','Spend 200 RP',state.rpTotal>=200],['Arcader','Finish a minigame',state.arcadeLastRewarded]];
        for(const r of rows){const rowH=48*DPR; CTX.fillStyle=r[2]?'#14211a':'#121821'; roundRect(listX,y,listW,rowH,10*DPR,true,false); CTX.fillStyle=r[2]?'#e2f6e9':'#e8f0f8'; CTX.font=`800 ${14*DPR}px Inter`; CTX.textAlign='left'; CTX.textBaseline='middle'; CTX.fillText(r[0],listX+12*DPR,y+rowH/2-10*DPR); CTX.fillStyle='#9fb0c6'; CTX.font=`600 ${12*DPR}px Inter`; CTX.fillText(r[1],listX+12*DPR,y+rowH/2+10*DPR); y+=rowH+8*DPR;}
      }

      if(state.tab==='Stats'){
        const stats=[['Bits',fmt(state.bits)],['Lifetime Bits',fmt(state.lifetimeBits)],['PPS (base)',fmt(totalPPS()/(1+state.combo.v))],['PPS (with combo)',fmt(totalPPS())],['RP',fmt(state.rp)],['RP/s',fmt(rpPerSec())],['Modules',state.modules.reduce((a,b)=>a+(b.count||0),0).toString()],['Cores',fmt(state.ascend.cores)]];
        for(const [k,v] of stats){const rowH=40*DPR; CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,8*DPR,true,false); CTX.fillStyle='#a9b9cf'; CTX.font=`600 ${12*DPR}px Inter`; CTX.textAlign='left'; CTX.textBaseline='middle'; CTX.fillText(k,listX+12*DPR,y+rowH/2); CTX.textAlign='right'; CTX.fillStyle='#e8f0f8'; CTX.font=`800 ${13*DPR}px Inter`; CTX.fillText(v,listX+listW-12*DPR,y+rowH/2); y+=rowH+8*DPR;}
      }

      if(state.tab==='Ascend'){
        const gain=coreGain(); const rowH=120*DPR; CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,10*DPR,true,false);
        CTX.fillStyle='#e8f0f8'; CTX.font=`800 ${16*DPR}px Inter`; CTX.textAlign='left'; CTX.textBaseline='top'; CTX.fillText('Ascend resets progress for permanent Cores',listX+12*DPR,y+10*DPR);
        CTX.fillStyle='#9fb0c6'; CTX.font=`600 ${13*DPR}px Inter`; CTX.fillText(`You would gain: ${gain} cores (global x${(1+(state.ascend.cores+gain)*0.1).toFixed(2)})`,listX+12*DPR,y+32*DPR);
        const bw=160*DPR,bh=36*DPR; const bx=listX+listW-bw-12*DPR, by=y+rowH-bh-12*DPR; drawButton(bx,by,bw,bh,'Ascend (P)',gain>0,true); addClick(bx,by,bw,bh,()=>tryAscend());
      }

      if(state.tab==='Settings'){
        const items=[['Particles','particles'],['Low FX','lowFX'],['Mute (M)','mute'],['Export (E)','export'],['Import (I)','import']];
        for(const it of items){
          const rowH=44*DPR; CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,8*DPR,true,false);
          CTX.fillStyle='#e8f0f8'; CTX.font=`700 ${13*DPR}px Inter`; CTX.textAlign='left'; CTX.textBaseline='middle'; CTX.fillText(it[0],listX+12*DPR,y+rowH/2);
          const bw=110*DPR,bh=30*DPR; const bx=listX+listW-bw-12*DPR, by=y+rowH/2-bh/2;
          if(it[1]==='export'){drawButton(bx,by,bw,bh,'Export',true,true);addClick(bx,by,bw,bh,()=>doExport());}
          else if(it[1]==='import'){drawButton(bx,by,bw,bh,'Import',true,true);addClick(bx,by,bw,bh,()=>doImport());}
          else{
            const key=it[1]; const val=state.settings[key];
            drawButton(bx,by,bw,bh,val?'ON':'OFF',true,val);
            addClick(bx,by,bw,bh,()=>{
              state.settings[key]=!state.settings[key];
              // secret unlock via spamming Particles toggle
              if(key==='particles'){
                state.cheat.taps = (state.cheat.taps||0) + 1;
                if(!state.cheat.unlocked && state.cheat.taps >= (state.cheat.req||50)){
                  unlockCheats();
                }
              }
            });
          }
          y+=rowH+8*DPR;
        }
        const rowH=60*DPR; CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,8*DPR,true,false);
        CTX.fillStyle='#e8f0f8'; CTX.font=`700 ${13*DPR}px Inter`; CTX.textAlign='left'; CTX.textBaseline='top'; CTX.fillText('Buy Quantity ([-] / [=])',listX+12*DPR,y+10*DPR);
        const wBtn=70*DPR; let bx=listX+12*DPR; const by=y+rowH-38*DPR;
        BUY_QTY.forEach((q,i)=>{const on=i===state.buyQtyIndex; drawButton(bx,by,wBtn,28*DPR,q.toString(),true,on); addClick(bx,by,wBtn,28*DPR,()=>{state.buyQtyIndex=i;}); bx+=wBtn+8*DPR;});
      }

      if(state.tab==='Cheats' && state.cheat.unlocked){
        const us=state.ui.scale||1;
        function row(label,desc,fn){
          const rowH=56*DPR*us;
          CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,10*DPR*us,true,false);
          const bw=180*DPR*us, bh=34*DPR*us, bx=listX+12*DPR*us, by=y+rowH/2-bh/2;
          drawButton(bx,by,bw,bh,label,true,true); addClick(bx,by,bw,bh,fn);
          CTX.fillStyle='#9fb0c6'; CTX.font=`600 ${12*DPR*us}px Inter`; CTX.textAlign='left'; CTX.textBaseline='middle';
          CTX.fillText(desc, bx+bw+14*DPR*us, y+rowH/2);
          y+=rowH+10*DPR*us;
        }
        row('+10K Bits','Quick cash', ()=>cheatAddBits(1e4));
        row('+1M Bits','Bigger boost', ()=>cheatAddBits(1e6));
        row('+100 RP','Research points', ()=>cheatAddRP(100));
        row('+1 Core','Adds a core (perm bonus)', ()=>cheatAddCores(1));
        row('Global x10 (toggle)','Multiply global output', ()=>cheatToggleX10());
        row('Unlock All Research','Applies all tech', ()=>cheatUnlockAll());
        row('Spawn Rift','Triggers a rift', ()=>cheatSpawnRift());
        row('Max Modules (100)','Sets each module to 100', ()=>cheatMaxModules(100));
      }

      CTX.restore();

      // Scroll
      state.ui.maxScroll = Math.max(0, (y + sOff) - (listY + listH));
      sOff = clamp(sOff, 0, state.ui.maxScroll);
      state.scroll[state.tab] = sOff;

      if(Math.abs(input.wheel)>0.1){ state.ui.scrollVel += input.wheel*0.6; input.wheel=0; }
      if(!state.ui.scrollDrag.active){
        if(Math.abs(state.ui.scrollVel)>0.1){
          sOff = clamp(sOff + state.ui.scrollVel, 0, state.ui.maxScroll);
          state.ui.scrollVel *= 0.86;
          state.scroll[state.tab]=sOff;
        }
      } else {
        state.ui.scrollVel *= 0.6;
      }
    }

    drawParticles(); drawArcade(); drawToasts();
  }

  function dispatchClick(px,py){
    if(state.rift.active&&tryClickRift(px,py)) return;
    for(let i=clicks.length-1;i>=0;i--){const c=clicks[i]; if(hit(px,py,c)){c.onClick(px,py); return;}}
    if(tryClickGlitch(px,py)) return;
  }

  function doExport(){try{const data=localStorage.getItem(SAVE_KEY)||JSON.stringify({...state,mults,mods}); if(navigator.clipboard&&location.protocol!=='file:'){navigator.clipboard.writeText(data).then(()=>toast('Save copied')).catch(()=>alert(data));}else alert(data);}catch{toast('Export failed');}}
  function doImport(){const data=prompt('Paste your save data:'); if(!data)return; try{localStorage.setItem(SAVE_KEY,data);toast('Imported. Reloading…');setTimeout(()=>location.reload(),400);}catch{toast('Import failed');}}

  let saveAcc=0; function autoSave(dt){saveAcc+=dt;if(saveAcc>10){saveAcc=0;save();}}
  let last=nowMs(); function loop(){resize();const t=nowMs();let dt=(t-last)/1000;last=t;dt=clamp(dt,0,0.1);if(state.settings.lowFX)dt*=0.9;update(dt);draw(dt);autoSave(dt);prevDown=input.down;requestAnimationFrame(loop);} loop();
})();
</script>
</body>
</html>
