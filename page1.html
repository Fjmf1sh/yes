<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Quantum Forge</title>
<style>
  :root{ color-scheme: dark; }
  html,body{height:100%;margin:0;background:#090c10;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  canvas{display:block;position:fixed;inset:0;width:100%;height:100%}
  *{ -webkit-tap-highlight-color: transparent; user-select: none; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<input id="importFile" type="file" accept=".qfs,application/json" style="display:none" />
<script>
(function(){
  'use strict';
  const CANVAS=document.getElementById('game');
  const CTX=CANVAS.getContext('2d',{alpha:false});
  const FILE_IN=document.getElementById('importFile');
  let DPR=Math.max(1,Math.min(3,(window.devicePixelRatio||1)));
  let prevDown=false;

  const THEME={
    bgTop:'#070b11',
    bgBot:'#0a0f17',
    panel:'#0b1117',
    panel2:'#101826',
    text:'#e6eef6',
    sub:'#9fb0c6',
    accent:'#7de2ff',
    accent2:'#a78bfa',
    accent3:'#22d3ee',
    good:'#34d399',
    warn:'#f59e0b',
    bad:'#ef4444'
  };

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const nowMs=()=>performance.now();
  const rand=(a,b)=>a+Math.random()*(b-a);
  const fmt=(n)=>{ if(!isFinite(n))return'âˆž'; if(n<1000)return n.toFixed(n<10?2:n<100?1:0);
    const U=['','K','M','B','T','Qa','Qi','Sx','Sp','Oc','No','Dc']; let i=0,x=n; while(x>=1000&&i<U.length-1){x/=1000;i++;} return x.toFixed(x<10?2:x<100?1:0)+U[i];
  };
  const measure=(txt,size,weight='600')=>{CTX.font=`${weight} ${size}px Inter,system-ui`;return CTX.measureText(txt).width;};

  function resize(){
    DPR=Math.max(1,Math.min(3,(window.devicePixelRatio||1)));
    const w=Math.max(320,Math.floor(CANVAS.clientWidth*DPR));
    const h=Math.max(320,Math.floor(CANVAS.clientHeight*DPR));
    if(CANVAS.width!==w||CANVAS.height!==h){CANVAS.width=w;CANVAS.height=h;}
  }
  window.addEventListener('resize',resize,{passive:true}); resize();

  const input={mx:0,my:0,down:false,wheel:0};
  function canvasPos(evt){const r=CANVAS.getBoundingClientRect();return {x:(evt.clientX-r.left)*DPR,y:(evt.clientY-r.top)*DPR};}
  function onPointerMove(e){
    const p=canvasPos(e); input.mx=p.x; input.my=p.y;
    const dr=state.ui.scrollDrag;
    if(dr.active){
      const dy=input.my-dr.lastY;
      if(state.overlay.researchOpen){
        const maxY=(state.researchMaxY||2000*DPR);
        state.scrollY = clamp((state.scrollY||0) - dy, 0, maxY);
      } else if(dr.tab===state.tab){
        const max=state.ui.maxScroll||0;
        state.scroll[state.tab]=clamp((state.scroll[state.tab]||0)-dy,0,max);
      }
      dr.vy=dy; dr.lastY=input.my;
    }
  }

  function onPointerDown(e){
    const p=canvasPos(e); input.mx=p.x; input.my=p.y; input.down=true;
    if(state.arcade.active && state.arcade.mode==='gate'){
      gateStop();
      return;
    }
    if(state.overlay.researchOpen){
      state.ui.scrollDrag={active:true,lastY:input.my,vy:0,tab:'ResearchOverlay'};
    }else{
      const r=state.ui.sideRect;
      if(r && input.mx>=r.x && input.mx<=r.x+r.w && input.my>=r.y && input.my<=r.y+r.h){
        state.ui.scrollDrag={active:true,lastY:input.my,vy:0,tab:state.tab};
      }
    }
  }

  function onPointerUp(e){
    const p=canvasPos(e); input.mx=p.x; input.my=p.y; input.down=false;
    if(state.ui.scrollDrag.active){
      if(state.overlay.researchOpen){
        state.ui.scrollDrag={active:false,lastY:0,vy:0,tab:null};
      }else{
        state.ui.scrollVel += -state.ui.scrollDrag.vy*0.8;
        state.ui.scrollDrag={active:false,lastY:0,vy:0,tab:null};
      }
    }
    dispatchClick(p.x,p.y);
  }
  CANVAS.addEventListener('pointermove',onPointerMove);
  CANVAS.addEventListener('pointerdown',onPointerDown);
  CANVAS.addEventListener('pointerup',onPointerUp);
  CANVAS.addEventListener('wheel',e=>{input.wheel+=e.deltaY;},{passive:true});

  window.addEventListener('keydown',async (e)=>{
    if(state.arcade.active){
      if(state.arcade.mode==='gate'&&(e.code==='Space'||e.key===' ')) gateStop();
      if(e.key==='Escape') endArcade();
      return;
    }
    if(e.key==='e'||e.key==='E') await doExport();
    if(e.key==='i'||e.key==='I') await doImport();
    if(e.key==='p'||e.key==='P') tryAscend();
    if(e.key==='m'||e.key==='M') state.settings.mute=!state.settings.mute;
    if(e.key==='-') cycleBuyQty(-1);
    if(e.key==='=') cycleBuyQty(+1);
    const idx='1234567890'.indexOf(e.key); if(idx!==-1) buyModule(idx);
    if(e.key==='Escape' && state.overlay.researchOpen){ state.overlay.researchOpen=false; }
  });

  let AC=null; function beep(f=420,d=0.05,v=0.02,type='triangle'){ if(state.settings.mute) return; try{ AC=AC||new (window.AudioContext||window.webkitAudioContext)(); const o=AC.createOscillator(),g=AC.createGain(); o.type=type;o.frequency.value=f;g.gain.value=v;o.connect(g);g.connect(AC.destination);o.start();o.stop(AC.currentTime+d);}catch{} }

  const MODULES=[
   {id:0, name:'Nanite Swarm', base:20, mult:1.15, prod:0.14},
   {id:1, name:'Signal Printer', base:130, mult:1.15, prod:1.5},
   {id:2, name:'Research Lab', base:500, mult:1.15, prod:0.005, rp:0.01},
   {id:3, name:'Biofarm', base:1400, mult:1.15, prod:10},
   {id:4, name:'Ore Synth', base:16000, mult:1.15, prod:25},
   {id:5, name:'Fusion Kiln', base:75000, mult:1.15, prod:80},
   {id:6, name:'Drone Spire', base:250000, mult:1.15, prod:200},
   {id:7, name:'Cryo Refinery', base:900000, mult:1.15, prod:600},
   {id:8, name:'Assembler', base:1750000, mult:1.15, prod:1500},
   {id:9, name:'Neuro Forge', base:9500000, mult:1.15, prod:5000},
   {id:10, name:'Biofabricator', base:35000000, mult:1.15, prod:12000},
   {id:11, name:'Quantum Farm', base:120000000, mult:1.15, prod:35000},
   {id:12, name:'Credit Node', base:600000000, mult:1.15, prod:100000},
   {id:13, name:'Flux Shrine', base:2500000000, mult:1.15, prod:350000},
   {id:14, name:'Time Fork', base:12000000000, mult:1.15, prod:1.2e6},
   {id:15, name:'Entropy Core', base:50000000000, mult:1.15, prod:4e6},
   {id:16, name:'Psi Relay', base:200000000000, mult:1.15, prod:1.5e7},
   {id:17, name:'Singularity', base:820000000000, mult:1.15, prod:6e7},
   {id:18, name:'Quantum Loom', base:12000000000000, mult:1.15, prod:2.5e8},
   {id:19, name:'Quantum Institute', base:180000000000000, mult:1.15, prod:8e8, rp:0.12},
   {id:20, name:'Grav Well', base:2700000000000000, mult:1.15, prod:3e9},
   {id:21, name:'Star Foundry', base:40000000000000000, mult:1.15, prod:1e10},
   {id:22, name:'Cosmic Lattice', base:650000000000000000, mult:1.15, prod:4e10},
   {id:23, name:'Omega Array', base:1e19, mult:1.15, prod:1.5e11},
   {id:24, name:'Neutrino Net', base:1e21, mult:1.15, prod:5e11},
   {id:25, name:'Axion Furnace', base:1e23, mult:1.15, prod:2e12},
   {id:26, name:'Quasar Loom', base:2.5e24, mult:1.15, prod:7e12},
   {id:27, name:'Dark-Matter Mill', base:7.5e25, mult:1.15, prod:2.5e13},
   {id:28, name:'Eternity Spire', base:4e26, mult:1.15, prod:7e13},
   {id:29, name:'Chrono Array', base:2e27, mult:1.15, prod:1.8e14, rp:0.25}
  ];

  const state={
    __version:13,
    bits:0,bitsTotal:0,lifetimeBits:0,
    rp:0,rpTotal:0,
    clickBase:1,clickMult:1,
    charge:{active:false,t:0,tMax:1.6},
    critZone:{lo:0.92,hi:1.0,mult:3},
    combo:{v:0,max:0.5,decay:0.12},
    modules:MODULES.map(m=>({id:m.id,count:0})),
    upgrades:[],tech:[],achievements:[],
    ascend:{cores:0,best:0},
    settings:{particles:true,mute:false,lowFX:false},
    cheat:{unlocked:false,taps:0,req:50,x10:false},
    lastSave:Date.now(),
    tab:'Forge',buyQtyIndex:0,
    researchCat:0,
    scroll:{Forge:0,Shop:0,Research:0,Arcade:0,Achievements:0,Stats:0,Ascend:0,Settings:0,Cheats:0},
    glitch:{next:rand(18,40),life:0,x:0,y:0,active:false,value:0},
    rift:{timer:rand(140,220),active:false,hp:0,hpMax:0,bitsReward:0,rpReward:0,prize:'bits',ttl:0,open:0,closing:false,wobble:0,stars:[]},
    particles:[],toast:[],
    arcade:{active:false,mode:null,t:0,score:0,pulses:[],gate:{x:0,v:0.9,zone:[0.45,0.55],tries:8,cooldown:0}},
    clickArea:null,
    ui:{
      drawerOpen:false,scale:1,sideRect:null,maxScroll:0,
      scrollDrag:{active:false,lastY:0,vy:0,tab:null},scrollVel:0
    },
    overlay:{researchOpen:false},
    _suspendSaves:false
  };

  const mults={global:1,modules:1,glitch:1,combo:1};
  const mods={clickCurve:1,rpGain:1,arcadeReward:1,riftHP:1,gateZone:1,pulseSize:1,pulseLife:1,costMult:1,glitchRate:1,riftReward:1};
  const BUY_QTY=[1,10,100,'Max'];

  const TREES=[
    {name:'Core', id:'core', items:[
      {id:'t_over1',tier:0,rp:50, pre:[],             name:'Overclock I',     desc:'+10% global',       apply:()=>{mults.global*=1.10;}},
      {id:'t_curve',tier:0,rp:25, pre:[],             name:'Harmonic Clicks', desc:'Pulses hit harder',  apply:()=>{mods.clickCurve*=1.5;}},
      {id:'t_glitch',tier:1,rp:80, pre:['t_over1'],   name:'Glitch Magnet',   desc:'+50% Glitch orbs',  apply:()=>{mults.glitch*=1.5;}},
      {id:'t_combo', tier:1,rp:150,pre:['t_curve'],   name:'Flux Combo',      desc:'Higher combo cap',   apply:()=>{state.combo.max=0.8; state.combo.decay=0.09;}},
      {id:'t_over2',tier:2,rp:200,pre:['t_over1'],    name:'Overclock II',    desc:'+20% global',       apply:()=>{mults.global*=1.20;}},
      {id:'t_corecrit',tier:2,rp:200,pre:['t_curve'], name:'Widen Crit',      desc:'Wider crit arc',     apply:()=>{state.critZone.lo=Math.max(0,state.critZone.lo-0.05); state.critZone.hi=Math.min(1,state.critZone.hi+0.02);}},
      {id:'t_over3',tier:3,rp:450,pre:['t_over2'],    name:'Overclock III',   desc:'+25% global',       apply:()=>{mults.global*=1.25;}},
      {id:'t_click2',tier:3,rp:500,pre:['t_curve'],   name:'Pulse Overdrive', desc:'+50% click payout', apply:()=>{state.clickMult*=1.5;}},
      {id:'t_over4',tier:4,rp:950,pre:['t_over3'],    name:'Overclock IV',    desc:'+30% global',       apply:()=>{mults.global*=1.30;}},
      {id:'t_crit2', tier:4,rp:700,pre:['t_corecrit'],name:'Critical Expansion',desc:'Even wider crit',  apply:()=>{state.critZone.lo=Math.max(0,state.critZone.lo-0.03); state.critZone.hi=Math.min(1,state.critZone.hi+0.02);}},
      {id:'t_charge1',tier:4,rp:680,pre:['t_over2'],  name:'Charge Tuning I', desc:'Charge fills faster',apply:()=>{state.charge.tMax=Math.max(1.2,state.charge.tMax*0.92);}},
      {id:'t_over5',tier:5,rp:1600,pre:['t_over4'],   name:'Overclock V',     desc:'+35% global',       apply:()=>{mults.global*=1.35;}},
      {id:'t_click3',tier:5,rp:1400,pre:['t_click2'], name:'Pulse Overdrive II',desc:'+75% click payout',apply:()=>{state.clickMult*=1.75;}},
      {id:'t_charge2',tier:5,rp:1200,pre:['t_charge1'],name:'Charge Tuning II',desc:'Charge much faster', apply:()=>{state.charge.tMax=Math.max(1.1,state.charge.tMax*0.88);}}
    ]},
    {name:'Labs', id:'labs', items:[
      {id:'t_lab',    tier:0,rp:120,pre:['t_over1'],     name:'Lab Protocols',    desc:'+60% RP gain',      apply:()=>{mods.rpGain*=1.6;}},
      {id:'t_riftdmp',tier:1,rp:300,pre:['t_lab'],       name:'Rift Dampers',     desc:'Rifts easier',       apply:()=>{mods.riftHP*=0.8;}},
      {id:'t_lab2',   tier:2,rp:700,pre:['t_lab'],       name:'Institute Grants', desc:'+50% RP gain',      apply:()=>{mods.rpGain*=1.5;}},
      {id:'t_rift2',  tier:3,rp:900,pre:['t_riftdmp'],   name:'Rift Shunts',      desc:'Rifts even easier',  apply:()=>{mods.riftHP*=0.85;}},
      {id:'t_mods',   tier:4,rp:600,pre:['t_over3'],     name:'Module Eff.',      desc:'+20% modules',      apply:()=>{mults.modules*=1.2;}},
      {id:'t_lab3',   tier:4,rp:1200,pre:['t_lab2'],     name:'Grand Fellowship', desc:'+45% RP gain',      apply:()=>{mods.rpGain*=1.45;}},
      {id:'t_cost1',  tier:5,rp:900,pre:['t_mods'],      name:'Bulk Procurement', desc:'Shop costs -5%',     apply:()=>{mods.costMult*=0.95;}},
      {id:'t_cost2',  tier:6,rp:1500,pre:['t_cost1'],    name:'Megascale Contracts',desc:'Shop costs -8%',    apply:()=>{mods.costMult*=0.92;}},
      {id:'t_rift3',  tier:6,rp:1400,pre:['t_rift2'],    name:'Rift Nullifiers',  desc:'Rifts trivialized',  apply:()=>{mods.riftHP*=0.85;}},
      {id:'t_riftrew',tier:6,rp:1300,pre:['t_rift2'],    name:'Rift Dividends',   desc:'+40% Rift rewards', apply:()=>{mods.riftReward*=1.4;}},
      {id:'t_glitchrate',tier:3,rp:700,pre:['t_glitch'], name:'Glitch Beacon',    desc:'More Glitch spawns', apply:()=>{mods.glitchRate*=1.35;}}
    ]},
    {name:'Arcade', id:'arcade', items:[
      {id:'t_gate',   tier:0,rp:220,pre:['t_curve'],     name:'Gate Precision',   desc:'Easier Timing Gate',   apply:()=>{mods.gateZone*=1.25;}},
      {id:'t_pulse',  tier:0,rp:180,pre:['t_curve'],     name:'Pulse Tuning',     desc:'Bigger/longer Pulse',  apply:()=>{mods.pulseSize*=1.15; mods.pulseLife*=1.2;}},
      {id:'t_arcade', tier:1,rp:260,pre:['t_lab'],       name:'Arcade Grants',    desc:'+30% arcade rewards', apply:()=>{mods.arcadeReward*=1.3;}},
      {id:'t_arcade2',tier:2,rp:520,pre:['t_arcade'],    name:'Arcade Stipend',   desc:'+25% arcade rewards', apply:()=>{mods.arcadeReward*=1.25;}},
      {id:'t_pulse2', tier:3,rp:600,pre:['t_pulse'],     name:'Pulse Tuning II',  desc:'Even bigger/longer',   apply:()=>{mods.pulseSize*=1.2; mods.pulseLife*=1.2;}},
      {id:'t_gate2',  tier:3,rp:620,pre:['t_gate'],      name:'Gate Precision II',desc:'Much easier Gate',     apply:()=>{mods.gateZone*=1.2;}},
      {id:'t_arcade3',tier:4,rp:820,pre:['t_arcade2'],   name:'Arcade Endowment', desc:'+25% arcade rewards', apply:()=>{mods.arcadeReward*=1.25;}},
      {id:'t_arcade4',tier:5,rp:1200,pre:['t_arcade3'],  name:'Arcade Jackpot',   desc:'+25% arcade rewards', apply:()=>{mods.arcadeReward*=1.25;}}
    ]},
    {name:'Quantum', id:'quantum', items:[
      {id:'t_combo2', tier:1,rp:420,pre:['t_combo'],     name:'Combo Sustain',    desc:'Slower combo decay',   apply:()=>{state.combo.decay=Math.max(0.05,state.combo.decay*0.7);}},
      {id:'t_time',   tier:2,rp:700,pre:['t_click2'],    name:'Time Compression', desc:'Charge faster',        apply:()=>{state.charge.tMax=Math.max(1.2,state.charge.tMax*0.9);}},
      {id:'t_glob',   tier:3,rp:1400,pre:['t_over4'],    name:'Planck Shift',     desc:'+15% global',         apply:()=>{mults.global*=1.15;}},
      {id:'t_combo3', tier:4,rp:1600,pre:['t_combo2'],   name:'Combo Lock',       desc:'Higher combo cap',     apply:()=>{state.combo.max=1.0;}},
      {id:'t_glob2',  tier:5,rp:2100,pre:['t_glob'],     name:'Vacuum Symmetry',  desc:'+20% global',         apply:()=>{mults.global*=1.20;}},
      {id:'t_qtime2', tier:5,rp:1800,pre:['t_time'],     name:'Temporal Folding', desc:'Charge even faster',   apply:()=>{state.charge.tMax=Math.max(1.0,state.charge.tMax*0.85);}},
      {id:'t_combo4', tier:6,rp:2400,pre:['t_combo3'],   name:'Combo Anchor',     desc:'Cap + decay â†“',        apply:()=>{state.combo.max=1.2; state.combo.decay=Math.max(0.04,state.combo.decay*0.75);}}
    ]},
    {name:'Economy', id:'economy', items:[
      {id:'e_bulk',      tier:0,rp:180,pre:[],            name:'Bulk Logistics',      desc:'Module output +10%', apply:()=>{mults.modules*=1.10;}},
      {id:'e_vendor',    tier:1,rp:350,pre:['e_bulk'],    name:'Vendor Network',      desc:'Shop costs -6%',     apply:()=>{mods.costMult=(mods.costMult||1)*0.94;}},
      {id:'e_synergy',   tier:2,rp:520,pre:['e_bulk'],    name:'Synergy Matrices',    desc:'Module output +15%', apply:()=>{mults.modules*=1.15;}},
      {id:'e_broker',    tier:3,rp:850,pre:['e_vendor'],  name:'Dimensional Brokers', desc:'Shop costs -8%',     apply:()=>{mods.costMult=(mods.costMult||1)*0.92;}},
      {id:'e_overdrive', tier:3,rp:900,pre:['e_synergy'], name:'Overdrive Plants',    desc:'+10% global',       apply:()=>{mults.global*=1.10;}},
      {id:'e_network',   tier:4,rp:1200,pre:['e_broker'], name:'Parallel Supply',     desc:'Module output +20%', apply:()=>{mults.modules*=1.20;}}
    ]},
    {name:'Defense', id:'defense', items:[
      {id:'d_warn',     tier:0,rp:200,pre:[],           name:'Beam Early Warning', desc:'(placeholder effect)', apply:()=>{mods.beamWarn=(mods.beamWarn||1)*1.25;}},
      {id:'d_cushion',  tier:1,rp:300,pre:['d_warn'],   name:'Kinetic Cushion',    desc:'Arcade penalties -20%', apply:()=>{mods.damageShield=(mods.damageShield||1)*0.8;}},
      {id:'d_observer', tier:2,rp:520,pre:['d_warn'],   name:'Trajectory Observer',desc:'Gate wider + pulses last', apply:()=>{mods.gateZone*=1.05; mods.pulseLife*=1.1;}},
      {id:'d_reflect',  tier:3,rp:900,pre:['d_cushion'],name:'Reflective Mesh',    desc:'+10% global',          apply:()=>{mults.global*=1.10;}}
    ]}
  ];
  const TECH = TREES.flatMap(tr => tr.items.map(it => ({...it, tree: tr.id})));

  const SAVE_KEY=('new_quantum_forge_v15@'+(location.host||'local'));
  function save(){ if(state._suspendSaves) return; state.lastSave=Date.now(); const data={...state,mults,mods}; try{localStorage.setItem(SAVE_KEY,JSON.stringify(data));}catch{} }
  function load(){
    try{
      let raw=localStorage.getItem(SAVE_KEY);
      if(!raw){ ensureDefaults(); return; }
      const d=JSON.parse(raw);
      const keep=['bits','bitsTotal','lifetimeBits','rp','rpTotal','clickBase','clickMult','charge','critZone','combo','modules','upgrades','tech','achievements','ascend','settings','cheat','lastSave','tab','buyQtyIndex','researchCat','scroll','glitch','rift','particles','toast','arcade','clickArea','ui'];
      for(const k of keep){ if(k in d) state[k]=d[k]; }
      if(d.mults) Object.assign(mults,d.mults);
      if(d.mods) Object.assign(mods,d.mods);
      ensureDefaults();
      const secs=clamp((Date.now()-(d.lastSave||Date.now()))/1000,0,3600*8);
      const pps=totalPPS(); const off=pps*secs*0.75; if(off>0){ addBits(off); toast(`Offline +${fmt(off)} bits`); }
    }catch{ ensureDefaults(); }
  }
  function ensureDefaults(){
    state.scrollY = state.scrollY || 0;
    state.ui = state.ui || {drawerOpen:false,scale:1,sideRect:null,maxScroll:0,scrollDrag:{active:false,lastY:0,vy:0,tab:null},scrollVel:0};
    const byId={}; (state.modules||[]).forEach(m=>{byId[m.id]=m;});
    state.modules = MODULES.map(m => byId[m.id] ? {id:m.id,count:byId[m.id].count||0} : {id:m.id,count:0});
  }
  load();
  document.addEventListener('visibilitychange',()=>{if(document.hidden)save();},{passive:true});
  window.addEventListener('beforeunload',()=>{try{save();}catch{}});

  function count(id){return state.modules[id]?.count||0;}
  function moduleCost(id,n){
    const m=MODULES[id],c=count(m.id); 
    const r=m.mult;
    const base=(m.base*mods.costMult)*(r**c);
    if(n===1) return base;
    return base*((r**n-1)/(r-1));
  }
  function moduleProd(id){const m=MODULES[id]; return (m.prod||0)*mults.modules*mults.global*(1+state.ascend.cores*0.1);}
  function totalPPS(){let v=0;for(const m of MODULES){v+=count(m.id)*moduleProd(m.id);}return v*(1+state.combo.v);}
  function rpPerSec(){ let rpv=0; for(const m of MODULES){ if(m.rp){ rpv += (m.rp||0)*count(m.id); } } return rpv*mods.rpGain; }

  function clickValueFromCharge(){
    const q=state.charge.t/state.charge.tMax; const curve=(q*q)*mods.clickCurve;
    return state.clickBase*state.clickMult*curve*(1+state.ascend.cores*0.1)*mults.global;
  }

  function canAfford(x){return state.bits>=x;}
  function maxAffordable(id){
    const m=MODULES[id];
    const r=m.mult;const c=count(id);
    const base=(m.base*mods.costMult)*(r**c); 
    if(state.bits<base) return 0; 
    const A=state.bits*(r-1)/base+1; 
    const n=Math.floor(Math.log(A)/Math.log(r)); 
    return Math.max(0,n);
  }
  function buyModule(id){const qty=BUY_QTY[state.buyQtyIndex]; let n=qty==='Max'?maxAffordable(id):qty; if(n<=0)return; const cost=moduleCost(id,n); if(!canAfford(cost))return; state.bits-=cost; state.modules[id].count+=n; beep(220+id*30,0.02,0.02);}
  function cycleBuyQty(d){state.buyQtyIndex=(state.buyQtyIndex+d+BUY_QTY.length)%BUY_QTY.length; toast(`Buy: ${BUY_QTY[state.buyQtyIndex]}`);}

  function addBits(v){if(!isFinite(v))return; state.bits+=v; state.bitsTotal+=v; state.lifetimeBits+=v;}
  function addRP(v){if(!isFinite(v))return; state.rp+=v; state.rpTotal+=v;}

  function hasTech(id){return state.tech.includes(id);}
  function techById(id){return TECH.find(t=>t.id===id);}
  function techAvailable(t){return !hasTech(t.id)&&t.pre.every(p=>hasTech(p));}
  function buyTech(t){if(!techAvailable(t)||state.rp<t.rp)return; state.rp-=t.rp; state.tech.push(t.id); t.apply(); toast(`Researched: ${t.name}`); beep(760,0.05,0.03);}

  function coreGain(){ return Math.floor(Math.sqrt(state.bits / 1e6)); }
  function tryAscend(){
    const gain = coreGain();
    if (gain <= 0) { toast('Generate more Bits to ascend'); return; }
    state.ascend.cores += gain;
    state.ascend.best = Math.max(state.ascend.best, state.ascend.cores);
    state.bits = 0; state.bitsTotal = 0; state.clickBase = 1; state.clickMult = 1;
    state.modules = MODULES.map(m => ({id: m.id, count: 0}));
    state.upgrades = []; state.rp = 0; state.tech = [];
    mults.global = 1; mults.modules = 1; mults.glitch = 1; mults.combo = 1;
    Object.assign(mods, {clickCurve:1,rpGain:1,arcadeReward:1,riftHP:1,gateZone:1,pulseSize:1,pulseLife:1,costMult:1,glitchRate:1,riftReward:1});
    state.charge = {active:false, t:0, tMax:1.6}; state.critZone = {lo:0.92, hi:1.0, mult:3}; state.combo = {v:0,max:0.5,decay:0.12};
    state.glitch = {next:rand(18,40), life:0, x:0, y:0, active:false, value:0};
    toast(`Ascended: +${gain} core(s) â†’ global x${(1 + state.ascend.cores*0.1).toFixed(2)}`);
    beep(880, 0.07, 0.03); save();
  }

  function updateGlitch(dt){
    const g=state.glitch;
    if(g.active){g.life-=dt; if(g.life<=0)g.active=false;}
    else{ 
      g.next-=dt; 
      if(g.next<=0){ 
        g.active=true; g.life=10; 
        const ca = state.clickArea;
        if(ca){
          const ang = rand(0, Math.PI*2);
          const rad = Math.sqrt(Math.random()) * Math.max(8*DPR, ca.R - 24*DPR);
          g.x = ca.cx + Math.cos(ang) * rad;
          g.y = ca.cy + Math.sin(ang) * rad;
        }else{
          g.x=rand(100,CANVAS.width-100); g.y=rand(120,CANVAS.height-160);
        }
        g.value=(totalPPS()*rand(8,24)+clickValueFromCharge()*rand(20,60))*mults.glitch; 
        g.next=rand(32,68)/mods.glitchRate;
        g.seed=(Math.random()*1e9)|0;
      } 
    }
  }
  function tryClickGlitch(px,py){
    const g=state.glitch; if(!g.active) return false;
    const d2=(px-g.x)**2+(py-g.y)**2; if(d2<=(28*DPR)**2){ addBits(g.value); g.active=false; particleBurst(g.x,g.y,18,THEME.accent3); toast(`Glitch +${fmt(g.value)}`); beep(1200,0.06,0.04,'sawtooth'); return true; }
    return false;
  }

  function updateRift(dt){
    const r=state.rift;
    if(r.active){
      r.wobble+=dt;
      if(!r.closing&&r.open<1) r.open=Math.min(1,r.open+dt*1.8);
      if(r.closing){
        r.open=Math.max(0,r.open-dt*1.8);
        if(r.open<=0){r.active=false;r.closing=false;r.timer=rand(170,240);r.stars=[];}
      }
    }else{
      r.timer-=dt;
      if(r.timer<=0){
        r.active=true;r.open=0;r.closing=false;r.wobble=0;
        const pps=Math.max(1,totalPPS());
        r.hpMax=pps*rand(40,70)*mods.riftHP; r.hp=r.hpMax;
        r.bitsReward=pps*rand(80,160)*mods.riftReward;
        r.rpReward=Math.max(5,pps*0.02*rand(20,40))*mods.riftReward;
        r.prize=Math.random()<0.5?'bits':'rp';
        r.ttl=30; r.stars.length=0; for(let i=0;i<100;i++) r.stars.push({x:Math.random(),y:Math.random(),a:rand(0.5,1)});
        toast('A Rift tears reality! Spam click to seal it!');
      }
    }
  }
  function riftRect(){
    const UIS=state.ui.scale||1; const pad=16*DPR*UIS, headerH=64*DPR*UIS;
    const compact=(CANVAS.width/DPR)<980;
    const sidebarW=compact?(state.ui.drawerOpen?Math.min(320*DPR,CANVAS.width-2*pad):0):Math.max(340*DPR,CANVAS.width*0.30);
    const mainX=pad, mainY=pad*2+headerH; const mainW=CANVAS.width-sidebarW-pad*3; const mainH=CANVAS.height-mainY-pad;
    const yMid=mainY+mainH*0.45; const h=clamp(state.rift.open,0,1)*Math.max(60*DPR,mainH*0.28);
    return {x:mainX+12*DPR,yMid,w:mainW-24*DPR,h};
  }
  function tryClickRift(px,py){
    const r=state.rift; if(!r.active) return false; const area=riftRect();
    if(px>=area.x&&px<=area.x+area.w&&Math.abs(py-area.yMid)<=area.h/2){
      const dmg=Math.max(5,totalPPS()*0.8+10);
      r.hp=Math.max(0,r.hp-dmg);
      particleBurst(px,py,6,THEME.accent2); beep(980,0.02,0.02,'square');
      if(r.hp<=0&&!r.closing){
        r.closing=true;
        if(r.prize==='bits'){ addBits(r.bitsReward); toast(`Rift sealed! +${fmt(r.bitsReward)} bits`); }
        else { addRP(r.rpReward); toast(`Rift sealed! +${fmt(r.rpReward)} RP`); }
      }
      return true;
    }
    return false;
  }

  const clicks=[]; function addClick(x,y,w,h,onClick){clicks.push({x,y,w,h,onClick});} function hit(px,py,r){return px>=r.x&&px<=r.x+r.w&&py>=r.y&&py<=r.y+r.h;}
  function drawButton(x,y,w,h,label,on=true,accent=false){const r=10*DPR;CTX.save();CTX.fillStyle=on?(accent?THEME.panel2:'#1a212b'):'#11161d';roundRect(x,y,w,h,r,true,false);CTX.fillStyle=on?THEME.text:'#7f8da0';CTX.font=`700 ${14*DPR}px Inter`;CTX.textAlign='center';CTX.textBaseline='middle';CTX.fillText(label,x+w/2,y+h/2);CTX.restore();}
  function drawBar(x,y,w,h,t,col=THEME.good){CTX.fillStyle='#10151b';roundRect(x,y,w,h,h/2,true,false);CTX.fillStyle=col;roundRect(x,y,w*clamp(t,0,1),h,h/2,true,false);}
  function roundRect(x,y,w,h,r,fill,stroke){CTX.beginPath();CTX.moveTo(x+r,y);CTX.arcTo(x+w,y,x+w,y+h,r);CTX.arcTo(x+w,y+h,x,y+h,r);CTX.arcTo(x,y+h,x,y,r);CTX.arcTo(x,y,x+w,y,r);CTX.closePath();if(fill)CTX.fill();if(stroke)CTX.stroke();}
  function pill(x,y,txt){const fs=12*DPR,pad=6*DPR,w=measure(txt,fs,'700')*DPR+pad*2,h=20*DPR;CTX.fillStyle='#141a21';roundRect(x,y,w,h,999,true,false);CTX.fillStyle=THEME.sub;CTX.font=`700 ${fs}px Inter`;CTX.textAlign='center';CTX.textBaseline='middle';CTX.fillText(txt,x+w/2,y+h/2);return{w,h};}
  function tooltip(x,y,lines){
    const fs=12*DPR; const pad=8*DPR;
    const w=Math.max(...lines.map(t=>measure(t,fs,'700')))*DPR + pad*2;
    const h=(fs+4*DPR)*lines.length + pad*2;
    let bx=x+14*DPR, by=y+14*DPR;
    if(bx+w>CANVAS.width-8*DPR) bx = x - w - 14*DPR;
    if(by+h>CANVAS.height-8*DPR) by = y - h - 14*DPR;
    CTX.fillStyle='#0c1117'; roundRect(bx,by,w,h,8*DPR,true,false);
    CTX.strokeStyle='#304256'; CTX.lineWidth=1*DPR; CTX.stroke();
    CTX.fillStyle=THEME.text; CTX.textAlign='left'; CTX.textBaseline='top'; CTX.font=`700 ${fs}px Inter`;
    let ty=by+pad; for(const t of lines){CTX.fillText(t,bx+pad,ty); ty+=fs+4*DPR;}
  }
  function toast(msg){state.toast.push({msg,t:2.6});}
  function particleBurst(x,y,n=12,color=THEME.accent){for(let i=0;i<n;i++){state.particles.push({x,y,vx:rand(-120,120),vy:rand(-180,-40),life:rand(0.4,0.9),age:0,color});}}
  function updateParticles(dt){for(let i=state.particles.length-1;i>=0;i--){const p=state.particles[i];p.age+=dt;p.x+=p.vx*dt;p.y+=p.vy*dt;p.vy+=220*dt;if(p.age>p.life)state.particles.splice(i,1);}}
  function drawParticles(){for(const p of state.particles){const t=1-p.age/p.life;CTX.globalAlpha=Math.max(0,t);CTX.fillStyle=p.color;CTX.fillRect(p.x,p.y,3*DPR,3*DPR);CTX.globalAlpha=1;}}
  function updateToasts(dt){for(let i=state.toast.length-1;i>=0;i--){const t=state.toast[i];t.t-=dt;if(t.t<=0)state.toast.splice(i,1);}}
  function drawToasts(){const fs=12*DPR;CTX.font=`700 ${fs}px Inter`;CTX.textAlign='center';let y=20*DPR;for(const t of state.toast){CTX.fillStyle='#0f141a';const w=measure(t.msg,fs,'700')*DPR+26*DPR;const h=24*DPR;const x=CANVAS.width/2-w/2;roundRect(x,y,w,h,10*DPR,true,false);CTX.fillStyle=THEME.text;CTX.fillText(t.msg,CANVAS.width/2,y+h/2);y+=h+8*DPR;}}

  function updateCharge(dt){
    const area=state.clickArea; if(!area) return;
    const inside=((input.mx-area.cx)**2+(input.my-area.cy)**2)<=area.R*area.R;
    if(input.down&&!prevDown&&inside){state.charge.active=true;}
    if(state.charge.active){
      if(input.down){
        state.charge.t=clamp(state.charge.t+dt*(1+(hasTech('t_over1')?0.15:0)),0,state.charge.tMax);
      }else{
        const base=clickValueFromCharge();
        const q=state.charge.t/state.charge.tMax; const inCrit=q>=state.critZone.lo&&q<=state.critZone.hi; const val=base*(inCrit?state.critZone.mult:1);
        addBits(val); particleBurst(input.mx,input.my,inCrit?18:10,inCrit?THEME.accent:THEME.accent2); beep(inCrit?820:520,inCrit?0.06:0.03);
        state.combo.v=clamp(state.combo.v+q*0.12,0,state.combo.max);
        addRP(q*0.4*mods.rpGain);
        state.charge.active=false; state.charge.t=0;
      }
    }
    if(!input.down){state.charge.active=false;}
  }

  function updateArcade(dt){
    if(!state.arcade.active) return;
    const A=state.arcade; A.t-=dt; if(A.t<=0){endArcade();return;}

    if(A.mode==='pulse'){
      const conf=A.pulse; 
      if(A.pulses.length<conf.maxOnScreen&&Math.random()<dt*conf.spawn){
        const life=conf.life;
        A.pulses.push({x:rand(120,CANVAS.width-120),y:rand(160,CANVAS.height-160),life,max:life});
      }
      for(let i=A.pulses.length-1;i>=0;i--){const p=A.pulses[i];p.life-=dt;if(p.life<=0)A.pulses.splice(i,1);}

    }else if(A.mode==='gate'){
      const g=A.gate;
      g.cooldown=Math.max(0,g.cooldown-dt);
      g.x+=g.v*dt; 
      if(g.x<0){g.x=0;g.v=Math.abs(g.v);} 
      if(g.x>1){g.x=1;g.v=-Math.abs(g.v);}

    }else if(A.mode==='meteor'){
      const M=A.meteor; M.px=input.mx; M.py=input.my; A.score+=dt*3.0;
      if(Math.random()<dt*M.spawn.rock) M.rocks.push({x:rand(30,CANVAS.width-30),y:-30*DPR,r:rand(22,52)*DPR,vy:rand(1.2,1.8)*M.speed});
      if(Math.random()<dt*M.spawn.comet){
        const x=rand(20,CANVAS.width-20), y=-40*DPR, vx=0, vy=rand(1.05,1.35)*M.speed;
        M.comets.push({x,y,r:rand(16,26)*DPR,vx,vy,homing:0.006,drift:rand(-0.3,0.3)});
      }
      if(Math.random()<dt*M.spawn.mine) M.mines.push({x:rand(40,CANVAS.width-40),y:-20*DPR,r:16*DPR,vy:rand(0.8,1.1)*M.speed,t:2.4});
      if(Math.random()<dt*M.spawn.beam) spawnBeam(M);
      if(Math.random()<dt*M.spawn.star) M.stars.push({x:rand(40,CANVAS.width-40),y:-10*DPR,r:8*DPR,vy:rand(0.9,1.2)*M.speed});

      for(let i=M.rocks.length-1;i>=0;i--){const k=M.rocks[i];k.y+=k.vy*dt;if(k.y>CANVAS.height+80*DPR)M.rocks.splice(i,1);}
      for(let i=M.comets.length-1;i>=0;i--){const c=M.comets[i]; c.x+=c.vx*dt; c.y+=c.vy*dt; if(c.y>CANVAS.height+120*DPR) M.comets.splice(i,1);}
      for(let i=M.mines.length-1;i>=0;i--){const m=M.mines[i]; m.y+=m.vy*dt; m.t-=dt; if(m.t<=0||m.y>CANVAS.height-40*DPR){ const N=10; const sp=rand(220,320)*DPR; for(let j=0;j<N;j++){const a=(Math.PI*2)*j/N + rand(-0.2,0.2); M.shards.push({x:m.x,y:m.y,r:6*DPR,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:1.6});} particleBurst(m.x,m.y,12,'#ffcf88'); M.mines.splice(i,1); beep(520,0.05,0.03,'square'); } }
      for(let i=M.shards.length-1;i>=0;i--){const s=M.shards[i]; s.x+=s.vx*dt; s.y+=s.vy*dt; s.life-=dt; if(s.life<=0) M.shards.splice(i,1);}
      for(let i=M.beams.length-1;i>=0;i--){const b=M.beams[i]; b.t-=dt; if(b.phase==='warn'&&b.t<=0){b.phase='fire'; b.t=b.fire;} else if(b.phase==='fire'&&b.t<=0){M.beams.splice(i,1);}}
      for(let i=M.stars.length-1;i>=0;i--){const k=M.stars[i];k.y+=k.vy*dt;if(k.y>CANVAS.height+30*DPR)M.stars.splice(i,1);}
      const pr=M.r; function hitCircle(cx,cy,cr){const d2=(cx-M.px)**2+(cy-M.py)**2; return d2<=(cr+pr)**2; }
      function penalize(amount=3){ A.score=Math.max(0,A.score-amount); beep(260,0.04,0.03,'sine'); particleBurst(M.px,M.py,8,'#ff9aa2'); }
      for(let i=M.rocks.length-1;i>=0;i--){const k=M.rocks[i]; if(hitCircle(k.x,k.y,k.r)){ penalize(3); M.rocks.splice(i,1);}}
      for(let i=M.comets.length-1;i>=0;i--){const k=M.comets[i]; if(hitCircle(k.x,k.y,k.r)){ penalize(3); M.comets.splice(i,1);}}
      for(let i=M.mines.length-1;i>=0;i--){const k=M.mines[i]; if(hitCircle(k.x,k.y,k.r*1.1)){ penalize(4); k.t=0; }}
      for(let i=M.shards.length-1;i>=0;i--){const k=M.shards[i]; if(hitCircle(k.x,k.y,k.r)){ penalize(2.5); M.shards.splice(i,1);}}
      for(const b of M.beams){ if(b.phase!=='fire') continue; if(b.dir==='h'){ const y=b.pos, half=b.th/2; if(M.py>y-half && M.py<y+half){ penalize(6); } } else { const x=b.pos, half=b.th/2; if(M.px>x-half && M.px<x+half){ penalize(6); } } }
      for(let i=M.stars.length-1;i>=0;i--){const k=M.stars[i]; if(hitCircle(k.x,k.y,k.r)){ A.score+=3; addRP(0.5*mods.rpGain); beep(900,0.03,0.02,'triangle'); particleBurst(k.x,k.y,6,'#a7f3d0'); M.stars.splice(i,1);}}
    }
  }

  function drawArcade(){
    if(!state.arcade.active) return;
    const A=state.arcade;
    CTX.globalAlpha=0.85;CTX.fillStyle='#000';CTX.fillRect(0,0,CANVAS.width,CANVAS.height);CTX.globalAlpha=1;
    const modeTitle={pulse:'Pulse Rush',gate:'Timing Gate',meteor:'Meteor Dodge+'}[A.mode]||'Arcade';
    CTX.fillStyle=THEME.text;CTX.font=`800 ${18*DPR}px Inter`;CTX.textAlign='center';CTX.fillText(`${modeTitle} â€” ${A.t.toFixed(1)}s`,CANVAS.width/2,60*DPR);

    if(A.mode==='pulse'){
      const conf=A.pulse; 
      for(const p of A.pulses){
        const t=p.life/p.max;
        const r=lerp(conf.rMin*DPR,conf.rMax*DPR,t);
        CTX.globalAlpha=Math.max(0.25,t);
        const g=CTX.createRadialGradient(p.x,p.y,1,p.x,p.y,r);
        g.addColorStop(0,THEME.accent);
        g.addColorStop(1,'rgba(125,226,255,0.05)');
        CTX.fillStyle=g; 
        CTX.beginPath();CTX.arc(p.x,p.y,r,0,Math.PI*2);CTX.fill();
        CTX.globalAlpha=1;
      }
      CTX.fillStyle=THEME.sub;CTX.font=`700 ${14*DPR}px Inter`;CTX.fillText(`Score: ${Math.floor(A.score)}`,CANVAS.width/2,90*DPR);

    }else if(A.mode==='gate'){
      const cx=CANVAS.width/2,y=CANVAS.height/2,W=520*DPR,H=22*DPR; 
      CTX.fillStyle='#121821'; roundRect(cx-W/2,y-H/2,W,H,10*DPR,true,false);
      const [zl,zh]=A.gate.zone; 
      const grad=CTX.createLinearGradient(cx-W/2+W*zl,y,cx-W/2+W*zh,y);
      grad.addColorStop(0,THEME.accent3); grad.addColorStop(1,THEME.accent2);
      CTX.fillStyle=grad; roundRect(cx-W/2+W*zl,y-H/2,W*(zh-zl),H,10*DPR,true,false);
      const mx=cx-W/2+W*A.gate.x; 
      CTX.fillStyle=THEME.text; roundRect(mx-5*DPR,y-10*DPR,10*DPR,20*DPR,3*DPR,true,false);
      CTX.fillStyle=THEME.sub;CTX.font=`700 ${14*DPR}px Inter`; 
      CTX.fillText(`Tries: ${A.gate.tries}  Score: ${Math.floor(A.score)}`,cx,y+40*DPR); 
      CTX.fillText(`Press Space OR Click the bar`,cx,y+62*DPR);

    }else if(A.mode==='meteor'){
      const M=A.meteor;
      for(const b of M.beams){
        if(b.phase==='warn'){
          CTX.globalAlpha=0.5+0.5*Math.sin(performance.now()/120);
          CTX.fillStyle='#314256';
          if(b.dir==='h') roundRect(0,b.pos-3*DPR,CANVAS.width,6*DPR,3*DPR,true,false);
          else roundRect(b.pos-3*DPR,0,6*DPR,CANVAS.height,3*DPR,true,false);
          CTX.globalAlpha=1;
        }else{
          CTX.globalAlpha=0.9;
          CTX.fillStyle='#c33';
          if(b.dir==='h') roundRect(0,b.pos-b.th/2,CANVAS.width,b.th,6*DPR,true,false);
          else roundRect(b.pos-b.th/2,0,b.th,CANVAS.height,6*DPR,true,false);
          CTX.globalAlpha=1;
        }
      }
      for(const k of M.rocks){CTX.fillStyle='#394553';CTX.beginPath();CTX.arc(k.x,k.y,k.r,0,Math.PI*2);CTX.fill();}
      for(const c of M.comets){CTX.fillStyle='#b8d7ff';CTX.beginPath();CTX.arc(c.x,c.y,c.r,0,Math.PI*2);CTX.fill();}
      for(const m of M.mines){CTX.fillStyle='#2d3744';CTX.beginPath();CTX.arc(m.x,m.y,m.r,0,Math.PI*2);CTX.fill();}
      for(const s of M.shards){CTX.fillStyle='#ffb38a'; CTX.beginPath(); CTX.arc(s.x,s.y,s.r,0,Math.PI*2); CTX.fill();}
      for(const s of M.stars){CTX.fillStyle='#9be7d7';CTX.beginPath();CTX.arc(s.x,s.y,s.r,0,Math.PI*2);CTX.fill();}
      CTX.fillStyle=THEME.text;CTX.beginPath();CTX.arc(M.px,M.py,M.r,0,Math.PI*2);CTX.fill();
      CTX.fillStyle=THEME.sub;CTX.font=`700 ${14*DPR}px Inter`;CTX.fillText(`Score: ${Math.floor(A.score)}`,CANVAS.width/2,90*DPR);
    }
  }

  function gateStop(){
    const A=state.arcade; if(!A.active||A.mode!=='gate')return;
    const g=A.gate;
    if(g.cooldown>0) return;
    const [zl,zh]=g.zone; const center=(zl+zh)/2; const width=(zh-zl);
    let add=0; let perfect=false;
    if(g.x>=zl && g.x<=zh){
      add=1;
      if(Math.abs(g.x-center)<=width*0.12){ add=2; perfect=true; }
      beep(perfect?880:720,perfect?0.06:0.04,0.03,perfect?'square':'triangle');
      particleBurst(CANVAS.width/2, CANVAS.height/2, perfect?14:8, perfect?THEME.good:THEME.accent);
    }else{
      beep(280,0.05,0.035,'sine');
    }
    A.score+=add;
    g.tries=Math.max(0,g.tries-1);
    const speedUp=1+rand(0.04,0.10);
    g.v = Math.sign(g.v)*Math.min(Math.abs(g.v)*speedUp, 2.2);
    g.cooldown=0.22;
    if(g.tries<=0) endArcade();
  }

  function startPulseRush(){
    state.arcade.active=true; state.arcade.mode='pulse'; state.arcade.t=25; state.arcade.score=0; state.arcade.pulses=[];
    state.arcade.pulse={spawn:0.55,life:3.0*mods.pulseLife,rMin:28*mods.pulseSize,rMax:52*mods.pulseSize,maxOnScreen:7};
    toast('Pulse Rush: click the orbs!');
  }
  function startGate(){
    state.arcade.active=true; state.arcade.mode='gate'; state.arcade.t=30; state.arcade.score=0;
    const w=0.10*mods.gateZone; state.arcade.gate={x:0.0,v:0.9,zone:[0.5-w/2,0.5+w/2],tries:8,cooldown:0}; toast('Timing Gate: press Space or click');
  }
  function startMeteor(){
    state.arcade.active=true; state.arcade.mode='meteor'; state.arcade.t=28; state.arcade.score=0;
    const speed=300*DPR;
    state.arcade.meteor={
      px:CANVAS.width/2, py:CANVAS.height*0.65, r:14*DPR,
      rocks:[], comets:[], mines:[], shards:[], beams:[], stars:[],
      spawn:{rock:7.5, comet:1.0, mine:1.2, beam:0.45, star:0.55},
      speed
    };
    toast('Meteor Dodge+: dodge meteors, shards & lasers.');
  }
  function spawnBeam(M){
    const horizontal=Math.random()<0.5;
    if(horizontal){
      const y=rand(120*DPR, CANVAS.height-120*DPR);
      M.beams.push({dir:'h',pos:y,phase:'warn',t:0.75,fire:1.00,th:26*DPR});
    }else{
      const x=rand(80*DPR, CANVAS.width-80*DPR);
      M.beams.push({dir:'v',pos:x,phase:'warn',t:0.75,fire:1.00,th:26*DPR});
    }
  }
  function endArcade(){
    if(!state.arcade.active) return;
    const s=Math.max(0,Math.floor(state.arcade.score)); const mode=state.arcade.mode; state.arcade.active=false;
    let bits=0,rp=0;
    if(mode==='pulse'){bits=s*3;rp=s*0.3;}
    else if(mode==='gate'){bits=s*8;rp=s*0.6;}
    else if(mode==='meteor'){bits=s*6;rp=s*0.45;}
    bits*=mods.arcadeReward; rp*=mods.arcadeReward;
    if(bits||rp){addBits(bits);addRP(rp);state.arcadeLastRewarded=true;toast(`Arcade reward: +${fmt(bits)} bits, +${fmt(rp)} RP`);}
  }

  function openResearch(){ state.overlay.researchOpen=true; }
  function drawResearch(){
    const clicksStart=clicks.length;
    CTX.globalAlpha=0.95; CTX.fillStyle='#05070a'; CTX.fillRect(0,0,CANVAS.width,CANVAS.height); CTX.globalAlpha=1;
    addClick(0,0,CANVAS.width,CANVAS.height,()=>{});

    const pad=20*DPR, headerH=60*DPR;
    CTX.fillStyle=THEME.panel; roundRect(pad,pad,CANVAS.width-pad*2,headerH,14*DPR,true,false);
    CTX.fillStyle=THEME.text; CTX.font=`800 ${18*DPR}px Inter`; CTX.textAlign='left'; CTX.textBaseline='middle';
    CTX.fillText('Research Tree', pad*2, pad+headerH/2);
    const cats=TREES.map(t=>t.name);
    const tabW=Math.max(90*DPR,Math.min(140*DPR,(CANVAS.width-2*pad-200*DPR)/cats.length));
    let tx=CANVAS.width - pad - (tabW+6*DPR)*cats.length, ty=pad+headerH/2-16*DPR, th=32*DPR;
    for(let i=0;i<cats.length;i++){
      const active=(i===state.researchCat);
      CTX.fillStyle=active?THEME.panel2:THEME.panel; roundRect(tx,ty,tabW,th,8*DPR,true,false);
      CTX.fillStyle=active?THEME.text:THEME.sub; CTX.font=`700 ${12*DPR}px Inter`; CTX.textAlign='center'; CTX.textBaseline='middle';
      CTX.fillText(cats[i],tx+tabW/2,ty+th/2);
      addClick(tx,ty,tabW,th,()=>{ state.researchCat=i; });
      tx+=tabW+6*DPR;
    }
    const cbw=90*DPR, cbh=34*DPR, cbx=pad*2+220*DPR, cby=pad+headerH/2-cbh/2;
    drawButton(cbx,cby,cbw,cbh,'Close (Esc)',true,true);
    addClick(cbx,cby,cbw,cbh,()=>{state.overlay.researchOpen=false;});

    const areaX=pad, areaY=pad*2+headerH, areaW=CANVAS.width-pad*2, areaH=CANVAS.height-areaY-pad;
    CTX.fillStyle='#0b1016'; roundRect(areaX,areaY,areaW,areaH,16*DPR,true,false);

    const tree=TREES[state.researchCat];
    const items=tree.items.slice();
    const tiers=[...new Set(items.map(i=>i.tier))].sort((a,b)=>a-b);
    const tierGap = 160*DPR;
    const rowGap  = 180*DPR;
    const leftPad = areaX + 80*DPR;
    const topPad  = areaY + 80*DPR - (state.scrollY||0);

    const byTier={}; for(const t of items){ (byTier[t.tier]||(byTier[t.tier]=[])).push(t); }
    for(const k in byTier){ byTier[k].sort((a,b)=> a.rp-b.rp || a.name.localeCompare(b.name)); }

    const pos={};
    for(let ti=0; ti<tiers.length; ti++){
      const t=tiers[ti];
      const arr=byTier[t];
      const totalWidth=(arr.length-1)*rowGap;
      const startX = leftPad + (areaW-160*DPR - totalWidth)/2;
      const y = topPad + ti * tierGap;
      for(let i=0;i<arr.length;i++){
        const x = startX + i*rowGap;
        pos[arr[i].id] = {x,y};
      }
      CTX.fillStyle='#233245'; CTX.font=`700 ${12*DPR}px Inter`; CTX.textAlign='left'; CTX.fillText(`Tier ${t}`, areaX+16*DPR, y+5*DPR);
      CTX.globalAlpha=0.15; CTX.strokeStyle='#294055'; CTX.beginPath(); CTX.moveTo(areaX+12*DPR,y+40*DPR); CTX.lineTo(areaX+areaW-12*DPR,y+40*DPR); CTX.stroke(); CTX.globalAlpha=1;
    }

    let lastTierY = 0;
    for (const t of tiers) { lastTierY = Math.max(lastTierY, (topPad + t * tierGap)); }
    const contentBottom = lastTierY + 220*DPR;
    const maxScrollY = Math.max(0, contentBottom - (areaY + areaH - 80*DPR));
    state.researchMaxY = maxScrollY;
    state.scrollY = clamp((state.scrollY||0), 0, state.researchMaxY);

    CTX.lineWidth=2*DPR;
    for(const t of items){
      for(const p of (t.pre||[])){
        const a=pos[p], b=pos[t.id]; if(!a||!b) continue;
        const owned=hasTech(p);
        CTX.strokeStyle= owned ? '#2b7a3f' : '#37485c';
        CTX.beginPath();
        CTX.moveTo(a.x, a.y+40*DPR);
        CTX.bezierCurveTo(a.x, a.y+90*DPR, b.x, b.y-90*DPR, b.x, b.y);
        CTX.stroke();
      }
    }

    for(const t of items){
      const p=pos[t.id]; if(!p) continue;
      const owned=hasTech(t.id);
      const can=state.rp>=t.rp && techAvailable(t);
      const R=34*DPR;
      CTX.save();
      CTX.shadowBlur=can?18*DPR:10*DPR;
      CTX.shadowColor=owned?THEME.good:(can?THEME.accent:THEME.panel);
      CTX.fillStyle= owned ? '#14211a' : (can ? THEME.panel2 : '#121821');
      CTX.beginPath(); CTX.arc(p.x, p.y, R, 0, Math.PI*2); CTX.fill(); CTX.restore();
      CTX.lineWidth=3*DPR; CTX.strokeStyle= owned ? THEME.good : (can ? '#93c5fd' : '#3b4a5c');
      CTX.beginPath(); CTX.arc(p.x, p.y, R+2*DPR, 0, Math.PI*2); CTX.stroke();
      CTX.fillStyle= owned ? '#c8f7da' : THEME.text;
      CTX.font=`800 ${12*DPR}px Inter`; CTX.textAlign='center'; CTX.textBaseline='middle';
      const label=t.name.length>18? t.name.slice(0,16)+'â€¦' : t.name;
      CTX.fillText(label, p.x, p.y-2*DPR);
      CTX.fillStyle=THEME.sub; CTX.font=`700 ${11*DPR}px Inter`;
      CTX.fillText(`${t.rp} RP`, p.x, p.y+14*DPR);
      const box=28*DPR;
      addClick(p.x-box, p.y-box, box*2, box*2, ()=>{ if(can) buyTech(t); });
      if( (input.mx-p.x)**2 + (input.my-p.y)**2 <= (R+8*DPR)**2 ){
        const reqs=(t.pre||[]).map(id=>techById(id)?.name||id);
        const lines=[t.name, `${t.rp} RP`, t.desc].concat(reqs.length?['Requires: '+reqs.join(', ')] : []);
        tooltip(p.x+R+10*DPR, p.y-R, lines);
      }
    }

    CTX.fillStyle=THEME.sub; CTX.font=`700 ${12*DPR}px Inter`;
    CTX.textAlign='left'; CTX.fillText(`RP: ${fmt(state.rp)}`, areaX+12*DPR, areaY+22*DPR);
    CTX.textAlign='right'; CTX.fillText('Click a sphere to research â€¢ Scroll to pan', areaX+areaW-12*DPR, areaY+22*DPR);

    if(Math.abs(input.wheel)>0.1){ state.scrollY = clamp((state.scrollY||0) + input.wheel*0.6, 0, (state.researchMaxY||2000*DPR)); input.wheel=0; }
  }

  function dispatchClick(px,py){
    if(state.arcade.active && state.arcade.mode==='pulse'){
      const conf=state.arcade.pulse;
      for(let i=state.arcade.pulses.length-1;i>=0;i--){
        const p=state.arcade.pulses[i];
        const t=p.life/p.max;
        const r=lerp(conf.rMin*DPR,conf.rMax*DPR,t);
        const d2=(px-p.x)**2+(py-p.y)**2;
        if(d2<=r*r){
          state.arcade.score+= (t<0.35?2:1);
          particleBurst(p.x,p.y,10, THEME.accent3);
          beep(820,0.05,0.03,'triangle');
          state.arcade.pulses.splice(i,1);
          return;
        }
      }
    }
    if(state.rift.active&&tryClickRift(px,py)) return;
    for(let i=clicks.length-1;i>=0;i--){const c=clicks[i]; if(hit(px,py,c)){c.onClick(px,py); return;}}
    if(tryClickGlitch(px,py)) return;
  }

  const enc = new TextEncoder(); const dec = new TextDecoder();
  function b64ab(buf){ return btoa(String.fromCharCode(...new Uint8Array(buf))); }
  function abB64(str){ const bin=atob(str); const out=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) out[i]=bin.charCodeAt(i); return out.buffer; }
  async function deriveKey(password, salt){
    const keyMat = await crypto.subtle.importKey('raw', enc.encode(password), 'PBKDF2', false, ['deriveKey']);
    return await crypto.subtle.deriveKey({name:'PBKDF2', hash:'SHA-256', salt, iterations:100000}, keyMat, {name:'AES-GCM', length:256}, false, ['encrypt','decrypt']);
  }
  async function doExport(){
    try{
      const pwd = prompt('Set a password to encrypt your save file:');
      if(!pwd){ toast('Export cancelled'); return; }
      const data={...state,mults,mods};
      const plain = enc.encode(JSON.stringify(data));
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key  = await deriveKey(pwd, salt);
      const cipher = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, plain);
      const wrapper = { v:1, algo:'AES-GCM', kdf:'PBKDF2-SHA256', it:100000, salt:b64ab(salt), iv:b64ab(iv), cipher:b64ab(cipher) };
      const blob = new Blob([JSON.stringify(wrapper)], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'quantum_forge_save.qfs';
      document.body.appendChild(a); a.click(); a.remove();
      toast('Encrypted save exported');
    }catch(e){ console.error(e); toast('Export failed'); }
  }
  async function doImport(){
    return new Promise((resolve)=>{
      FILE_IN.onchange=async ()=>{
        const file = FILE_IN.files[0]; FILE_IN.value='';
        if(!file){ toast('No file selected'); resolve(); return; }
        try{
          const txt = await file.text();
          let wrapper; try{ wrapper = JSON.parse(txt); }catch{ wrapper=null; }
          if(wrapper && wrapper.v===1 && wrapper.cipher && wrapper.salt && wrapper.iv){
            const pwd = prompt('Enter password to decrypt:');
            if(!pwd){ toast('Import cancelled'); resolve(); return; }
            const salt = abB64(wrapper.salt);
            const iv   = abB64(wrapper.iv);
            const key  = await deriveKey(pwd, salt);
            const plainBuf = await crypto.subtle.decrypt({name:'AES-GCM', iv:new Uint8Array(iv)}, key, abB64(wrapper.cipher));
            const json = dec.decode(plainBuf);
            state._suspendSaves = true;
            localStorage.setItem(SAVE_KEY, json);
          }else{
            state._suspendSaves = true;
            localStorage.setItem(SAVE_KEY, txt);
          }
          toast('Imported. Reloadingâ€¦');
          setTimeout(()=>{ state._suspendSaves = true; location.replace(location.href); }, 300);
          resolve();
        }catch(e){ console.error(e); toast('Import failed'); resolve(); }
      };
      FILE_IN.click();
    });
  }
  function resetProgress(){
    if(confirm('Reset ALL progress? This cannot be undone.')){
      try{ state._suspendSaves = true; localStorage.removeItem(SAVE_KEY); }catch{}
      toast('Progress reset. Reloadingâ€¦'); setTimeout(()=>{ state._suspendSaves = true; location.replace(location.href); }, 250);
    }
  }

  function drawQuantumTheme(){
    const cx=CANVAS.width/2, cy=CANVAS.height/2, r=Math.hypot(CANVAS.width, CANVAS.height)*0.6;
    const rad=CTX.createRadialGradient(cx,cy,Math.max(10*DPR,r*0.05),cx,cy,r);
    rad.addColorStop(0, '#0a1522');
    rad.addColorStop(1, THEME.bgBot);
    CTX.fillStyle=rad; CTX.fillRect(0,0,CANVAS.width,CANVAS.height);

    CTX.save();
    CTX.globalAlpha=0.06;
    CTX.strokeStyle='#6ee7ff';
    CTX.lineWidth=1*DPR;
    const s=64*DPR; const t=nowMs()*0.0003;
    CTX.beginPath();
    for(let x=((t*30)%s)-s; x<CANVAS.width; x+=s){CTX.moveTo(x,0);CTX.lineTo(x,CANVAS.height);}
    for(let y=((t*30)%s)-s; y<CANVAS.height; y+=s){CTX.moveTo(0,y);CTX.lineTo(CANVAS.width,y);}
    CTX.stroke();
    CTX.restore();

    CTX.save();
    CTX.globalAlpha=0.25;
    CTX.strokeStyle=THEME.accent2;
    CTX.lineWidth=2*DPR;
    const rings=3;
    for(let i=0;i<rings;i++){
      const rr = r*(0.35 + 0.1*i) + Math.sin(nowMs()/1000 + i)*6*DPR;
      CTX.beginPath(); CTX.arc(cx,cy,rr,0,Math.PI*2); CTX.stroke();
    }
    CTX.restore();
  }

  // ====== NEW: Proper "glitch" orb renderer (datamosh slices + chroma + pixel snow) ======
  function drawGlitchOrb(x, y, Rg, seed){
    const t = performance.now()/1000;
    CTX.save();
    CTX.translate(x, y);

    const jx = (Math.sin((t*12.3 + seed)%100)*2 - 1) * 2*DPR;
    const jy = (Math.cos((t*15.7 + seed)%100)*2 - 1) * 2*DPR;
    CTX.translate(jx, jy);
    CTX.rotate((Math.sin(t*6.2+seed)*0.06));

    // Keep a circular silhouette
    CTX.beginPath(); CTX.arc(0,0,Rg,0,Math.PI*2); CTX.clip();

    // noisy scanline field
    for(let i=-Rg; i<Rg; i+=3*DPR){
      const off = (Math.sin(t*24+i*0.35)+Math.cos(t*13+i*0.57))*3*DPR;
      CTX.fillStyle = (i%(6*DPR)===0)?'#08f7f2':'#c084fc';
      CTX.globalAlpha = 0.75;
      CTX.fillRect(-Rg+off, i, Rg*2, 2*DPR);
    }
    CTX.globalAlpha=1;

    // broken horizontal slices
    for(let k=0;k<7;k++){
      const yy = (Math.sin((k*17.3+seed)+t*7.1)*Rg*0.8);
      const hh = (0.12 + (Math.sin((k*3.9+seed)+t*9.3)*0.3+0.3)) * 7*DPR;
      const dx = (Math.sin((k*5.7+seed)+t*11.7))*7*DPR;
      CTX.globalCompositeOperation='lighter';
      CTX.fillStyle = k%2? '#22d3ee' : '#a78bfa';
      CTX.fillRect(-Rg+dx, yy, Rg*2, hh);
    }
    CTX.globalCompositeOperation='source-over';

    // pixel snow
    const snow=44;
    for(let i=0;i<snow;i++){
      const ang = (i*12.9898+seed)%6.283 + t*0.4;
      const rr = (Math.sin(i*78.233+seed)*0.5+0.5) * Rg*0.95;
      const px = Math.cos(ang)*rr;
      const py = Math.sin(ang)*rr;
      const s2 = ( (i%5)/5 + 0.25 ) * 2*DPR;
      CTX.fillStyle = (i%3===0)? '#e2fdff' : (i%3===1? '#7de2ff' : '#a78bfa');
      CTX.globalAlpha = 0.85*(0.4+0.6*((i*43758.5453)%1));
      CTX.fillRect(px,py,s2,s2);
    }
    CTX.globalAlpha=1;

    // exterior chroma ring
    for(const [dx, col, alp] of [[-1*DPR,'#22d3ee',0.65],[1*DPR,'#a78bfa',0.65]]){
      CTX.strokeStyle = col; CTX.globalAlpha=alp;
      CTX.lineWidth=3*DPR; CTX.beginPath(); CTX.arc(dx,0,Rg*0.95,0,Math.PI*2); CTX.stroke();
    }
    CTX.globalAlpha=1;
    CTX.restore();
  }

  function update(dt){
    addBits(totalPPS()*dt); addRP(rpPerSec()*dt);
    state.combo.v=clamp(state.combo.v-state.combo.decay*dt,0,state.combo.max);
    updateGlitch(dt); updateRift(dt); updateArcade(dt); updateCharge(dt); updateParticles(dt); updateToasts(dt);
  }

  function draw(dt){
    clicks.length=0; 
    drawQuantumTheme();

    const UIS=clamp(Math.min(CANVAS.width/(1280*DPR),CANVAS.height/(720*DPR)),0.8,1.15);
    state.ui.scale=UIS;
    const pad=16*DPR*UIS, headerH=64*DPR*UIS; const compact=(CANVAS.width/DPR)<980;
    let sidebarW=compact?(state.ui.drawerOpen?Math.min(320*DPR,CANVAS.width-2*pad):0):Math.max(340*DPR,CANVAS.width*0.30);

    CTX.save(); CTX.globalAlpha=0.88;
    CTX.fillStyle=THEME.panel; roundRect(pad,pad,CANVAS.width-pad*2,headerH,14*DPR,true,false);
    CTX.restore();

    const titleX=pad*2, titleY=pad+headerH/2;
    const grad=CTX.createLinearGradient(titleX-10*DPR,titleY,titleX+220*DPR,titleY);
    grad.addColorStop(0,THEME.accent3); grad.addColorStop(1,THEME.accent2);
    CTX.fillStyle=grad; CTX.font=`800 ${20*DPR*state.ui.scale}px Inter`; CTX.textAlign='left'; CTX.textBaseline='middle'; CTX.fillText('Quantum Forge',titleX,titleY);
    let xr=CANVAS.width-pad*2-100*DPR; pill(xr,pad+headerH/2-10*DPR,`Buy: ${BUY_QTY[state.buyQtyIndex]}`); addClick(xr,pad+headerH/2-10*DPR,100*DPR,20*DPR,()=>cycleBuyQty(+1));
    xr-=150*DPR; pill(xr,pad+headerH/2-10*DPR,`Cores: ${fmt(state.ascend.cores)} (x${(1+state.ascend.cores*0.1).toFixed(2)})`);
    if(compact){
      const bw=36*DPR,bh=32*DPR; const bx=CANVAS.width-pad-bw, by=pad+headerH/2-bh/2;
      drawButton(bx,by,bw,bh,state.ui.drawerOpen?'âœ•':'â‰¡',true,true); addClick(bx,by,bw,bh,()=>{state.ui.drawerOpen=!state.ui.drawerOpen;});
    }

    const mainX=pad, mainY=pad*2+headerH; const mainW=CANVAS.width-sidebarW-pad*3; const mainH=CANVAS.height-mainY-pad;
    const sideX=CANVAS.width-sidebarW-pad, sideY=mainY, sideH=mainH;

    CTX.save(); CTX.globalAlpha=0.88;
    CTX.fillStyle=THEME.panel; roundRect(mainX,mainY,mainW,mainH,16*DPR,true,false);
    CTX.restore();

    (function(){
      const padHUD=10*DPR*UIS, f1=(16*UIS)*DPR, f2=(12*UIS)*DPR;
      const l1=`Bits: ${fmt(state.bits)}`, l2=`PPS: ${fmt(totalPPS())}   RP: ${fmt(state.rp)}`;
      CTX.font=`800 ${f1}px Inter`; const w1=CTX.measureText(l1).width; CTX.font=`700 ${f2}px Inter`; const w2=CTX.measureText(l2).width;
      const w=Math.max(w1,w2)+padHUD*2, h=f1+f2+padHUD*3, bx=mainX+(mainW-w)/2, by=mainY+8*DPR;
      CTX.fillStyle=THEME.panel2; roundRect(bx,by,w,h,10*DPR,true,false);
      CTX.fillStyle=THEME.text; CTX.font=`800 ${f1}px Inter`; CTX.textAlign='center'; CTX.textBaseline='top'; CTX.fillText(l1,bx+w/2,by+padHUD*0.8);
      CTX.fillStyle=THEME.sub; CTX.font=`700 ${f2}px Inter`; CTX.fillText(l2,bx+w/2,by+padHUD*0.8+f1+6*DPR);
    })();

    const cx=mainX+mainW*0.5, cy=mainY+mainH*(compact?0.60:0.58); const R=Math.min(mainW,mainH)*(compact?0.28:0.32);
    state.clickArea={cx,cy,R};
    CTX.save(); CTX.shadowBlur=36*DPR; CTX.shadowColor='#213141'; CTX.fillStyle='#16202b'; CTX.beginPath(); CTX.arc(cx,cy,R,0,Math.PI*2); CTX.fill(); CTX.restore();
    const q=state.charge.t/state.charge.tMax; CTX.lineWidth=8*DPR; CTX.strokeStyle='#2d4156'; CTX.beginPath(); CTX.arc(cx,cy,R-14*DPR,-Math.PI/2,-Math.PI/2+Math.PI*2*q); CTX.stroke();
    const a1=-Math.PI/2+Math.PI*2*state.critZone.lo, a2=-Math.PI/2+Math.PI*2*state.critZone.hi; 
    const arcGrad=CTX.createLinearGradient(cx,cy-R,cx,cy+R);
    arcGrad.addColorStop(0,THEME.accent3); arcGrad.addColorStop(1,THEME.accent2);
    CTX.strokeStyle=arcGrad; CTX.lineWidth=6*DPR; CTX.beginPath(); CTX.arc(cx,cy,R-18*DPR,a1,a2); CTX.stroke();
    CTX.fillStyle=THEME.text; CTX.font=`800 ${22*DPR}px Inter`; CTX.textAlign='center'; CTX.textBaseline='middle'; CTX.fillText(state.charge.active?'RELEASE':'HOLD',cx,cy);

    // === Glitch orb (true glitch visual) ===
    if(state.glitch.active){
      const Rg=18*DPR;
      drawGlitchOrb(state.glitch.x, state.glitch.y, Rg, state.glitch.seed||0);
      addClick(state.glitch.x-20*DPR,state.glitch.y-20*DPR,40*DPR,40*DPR,(px,py)=>{tryClickGlitch(px,py);});
    }

    if(state.rift.active){
      const r=state.rift, rect=riftRect(), x=rect.x, w=rect.w, yMid=rect.yMid, h=rect.h;
      const amp=8*DPR*r.open;
      CTX.save();
      CTX.globalAlpha=0.55*r.open; CTX.fillStyle='#000'; CTX.fillRect(0,0,CANVAS.width,CANVAS.height); CTX.globalAlpha=1;

      function edgePath(offset,phase){
        const segs=22; CTX.beginPath();
        CTX.moveTo(x, yMid-h/2+offset);
        for(let i=1;i<=segs;i++){
          const t=i/segs;
          const xx=x+w*t;
          const yy=yMid-h/2 + offset + Math.sin((t*12 + r.wobble*2 + phase))*amp + Math.sin((t*33 + r.wobble*4 + phase))*amp*0.25;
          CTX.lineTo(xx,yy);
        }
      }
      CTX.beginPath();
      edgePath(0,0);
      CTX.lineTo(x+w, yMid+h/2);
      for(let i=22;i>=0;i--){
        const t=i/22;
        const xx=x+w*t;
        const yy=yMid+h/2 + Math.sin((t*12 + r.wobble*2 + Math.PI))*amp + Math.sin((t*33 + r.wobble*4 + Math.PI))*amp*0.25;
        CTX.lineTo(xx,yy);
      }
      CTX.closePath();
      const inner=CTX.createLinearGradient(x,yMid-h/2,x+w,yMid+h/2);
      inner.addColorStop(0,'#05070a'); inner.addColorStop(0.5,'#02040a'); inner.addColorStop(1,'#05070a');
      CTX.fillStyle=inner; CTX.fill();

      for(const s of r.stars){
        const sx=x+s.x*w, sy=yMid-h/2+s.y*h + Math.sin(r.wobble*2 + s.x*10)*3*DPR;
        CTX.globalAlpha=s.a; CTX.fillStyle=THEME.accent;
        CTX.fillRect(sx,sy,2*DPR,2*DPR);
      }
      CTX.globalAlpha=1;

      for(const [dx,color] of [[-1*DPR,'#7dd3fc'],[0,THEME.accent2],[1*DPR,'#22d3ee']]){
        CTX.strokeStyle=color; CTX.lineWidth=2*DPR;
        edgePath(0,0); CTX.stroke();
        CTX.beginPath();
        CTX.moveTo(x+dx, yMid+h/2);
        const segs=22;
        for(let i=1;i<=segs;i++){
          const t=i/segs;
          const xx=x+dx+w*t;
          const yy=yMid+h/2 + Math.sin((t*12 + r.wobble*2 + Math.PI))*amp + Math.sin((t*33 + r.wobble*4 + Math.PI))*amp*0.25;
          CTX.lineTo(xx,yy);
        }
        CTX.stroke();
      }

      CTX.fillStyle=THEME.text; CTX.font=`800 ${16*DPR}px Inter`; CTX.textAlign='center'; 
      CTX.fillText('RIFT! SPAM-CLICK!',x+w/2,yMid-h/2-28*DPR);
      const barW=Math.min(w*0.7,520*DPR), barH=16*DPR, bx=x+(w-barW)/2, by=yMid+h/2+12*DPR; 
      drawBar(bx,by,barW,barH,1-r.hp/r.hpMax,THEME.bad);
      CTX.fillStyle=THEME.sub; CTX.font=`700 ${12*DPR}px Inter`; 
      const prizeTxt=r.prize==='bits'?`Reward: ${fmt(r.bitsReward)} bits`:`Reward: ${fmt(r.rpReward)} RP`; 
      CTX.fillText(prizeTxt,x+w/2,by+barH+16*DPR);
      CTX.restore();
    }

    if(sidebarW>0){
      CTX.save(); CTX.globalAlpha=0.88;
      CTX.fillStyle=THEME.panel; roundRect(sideX,sideY,sidebarW,sideH,16*DPR,true,false);
      CTX.restore();
      const tabs=['Forge','Shop','Research','Arcade','Achievements','Stats','Ascend','Settings'];
      if(state.cheat.unlocked) tabs.push('Cheats');
      const tabH=40*DPR; let tx=sideX; const tw=sidebarW/tabs.length; const tabFs=tw<90*DPR?11*DPR:13*DPR;
      for(const tname of tabs){
        const active=state.tab===tname;
        CTX.fillStyle=active?THEME.panel2:THEME.panel; roundRect(tx,sideY,tw,tabH,10*DPR,true,false);
        CTX.fillStyle=active?THEME.text:THEME.sub; CTX.font=`700 ${tabFs}px Inter`; CTX.textAlign='center'; CTX.textBaseline='middle'; CTX.fillText(tname,tx+tw/2,sideY+tabH/2);
        addClick(tx,sideY,tw,tabH,()=>{state.tab=tname; state.ui.scrollVel=0;});
        tx+=tw;
      }

      const listX=sideX+10*DPR, listY=sideY+tabH+10*DPR, listW=sidebarW-20*DPR, listH=sideH-tabH-20*DPR;
      CTX.save(); CTX.beginPath(); CTX.rect(listX,listY,listW,listH); CTX.clip();
      state.ui.sideRect = {"x": listX, "y": listY, "w": listW, "h": listH};
      let sOff=state.scroll[state.tab]||0; let y=listY - sOff;

      if(state.tab==='Forge'){
        const rowH=70*DPR; CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,10*DPR,true,false);
        CTX.fillStyle=THEME.sub; CTX.font=`600 ${12*DPR}px Inter`; CTX.textAlign='left'; CTX.textBaseline='top';
        CTX.fillText(`Combo: ${(state.combo.v*100).toFixed(0)}% (decay ${Math.round(state.combo.decay*100)}%/s)`,listX+12*DPR,y+12*DPR);
        CTX.fillText(`PPS (after combo): ${fmt(totalPPS())} | RP/s: ${fmt(rpPerSec())}`,listX+12*DPR,y+32*DPR);
        y+=rowH+10*DPR;
        const rowH2=80*DPR; CTX.fillStyle=THEME.panel; roundRect(listX,y,listW,rowH2,10*DPR,true,false);
        CTX.fillStyle=THEME.sub; CTX.font=`600 ${12*DPR}px Inter`;
        CTX.fillText('Hold inside the core to charge. Release in the highlighted arc for critical payout. Play Arcade for bursts & RP.',listX+12*DPR,y+14*DPR);
        y+=rowH2+10*DPR;
      }

      if(state.tab==='Shop'){
        const us=state.ui.scale||1, isNarrow=listW<460*DPR*us, baseRowH=(isNarrow?92:70)*DPR*us;
        for(const m of MODULES){
          const n=count(m.id), qty=BUY_QTY[state.buyQtyIndex], nToBuy=qty==='Max'?maxAffordable(m.id):qty;
          const cost=moduleCost(m.id,nToBuy), afford=nToBuy>0&&state.bits>=cost, rowH=baseRowH;
          CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,10*DPR*us,true,false);
          const nameX=listX+12*DPR*us, nameY=y+10*DPR*us;
          CTX.fillStyle=THEME.text; CTX.font=`800 ${15*DPR*us}px Inter`; CTX.textAlign='left'; CTX.textBaseline='top'; CTX.fillText(m.name,nameX,nameY);
          const label=qty==='Max'?`Buy ${nToBuy}`:`Buy x${nToBuy}`;
          const fsBtn=14*DPR*us; CTX.font=`700 ${fsBtn}px Inter`;
          const bw=Math.max(100*DPR*us,CTX.measureText(label).width+28*DPR*us), bh=32*DPR*us;
          const bx=listX+listW-bw-12*DPR*us, by=y+rowH-bh-10*DPR*us;
          if(isNarrow){
            CTX.fillStyle=afford?THEME.good:THEME.sub; CTX.font=`800 ${13*DPR*us}px Inter`; CTX.textAlign='left';
            CTX.fillText(`Cost: ${fmt(cost)}`,nameX,nameY+20*DPR*us);
            CTX.fillStyle=THEME.sub; CTX.font=`600 ${12*DPR*us}px Inter`;
            const rpLine = m.rp?` â€¢ RP: ${m.rp}/s`:'';
            CTX.fillText(`Owned: ${n} â€¢ +${fmt(moduleProd(m.id))}/s${rpLine}`,nameX,nameY+38*DPR*us);
          }else{
            CTX.fillStyle=THEME.sub; CTX.font=`600 ${12*DPR*us}px Inter`; CTX.textAlign='left';
            const rpLine = m.rp?` â€¢ RP: ${m.rp}/s`:'';
            CTX.fillText(`Owned: ${n} â€¢ +${fmt(moduleProd(m.id))}/s${rpLine}`,nameX,nameY+22*DPR*us);
            CTX.fillStyle=afford?THEME.good:THEME.sub; CTX.font=`800 ${14*DPR*us}px Inter`; CTX.textAlign='right';
            CTX.fillText(`Cost: ${fmt(cost)}`,bx-12*DPR*us,nameY+2*DPR*us);
          }
          drawButton(bx,by,bw,bh,label,afford,true); addClick(bx,by,bw,bh,()=>buyModule(m.id));
          y+=rowH+10*DPR*us;
        }
      }

      if(state.tab==='Research'){
        const rowH=60*DPR; CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,10*DPR,true,false);
        CTX.fillStyle=THEME.text; CTX.font=`800 ${16*DPR}px Inter`; CTX.textAlign='left'; CTX.textBaseline='middle';
        CTX.fillText('Open Research Tree', listX+14*DPR, y+rowH/2);
        const bw=180*DPR,bh=34*DPR; const bx=listX+listW-bw-12*DPR, by=y+rowH/2-bh/2;
        drawButton(bx,by,bw,bh,'Open Tree',true,true); addClick(bx,by,bw,bh,openResearch);
        y+=rowH+10*DPR;
        CTX.fillStyle=THEME.sub; CTX.font=`700 ${12*DPR}px Inter`; CTX.fillText(`Owned: ${state.tech.length} â€¢ RP: ${fmt(state.rp)}`,listX+12*DPR,y+14*DPR);
      }

      if(state.tab==='Arcade'){
        const us=state.ui.scale||1, isNarrow=listW<500*DPR*us;
        function row(title,desc,onClick){
          const fs=14*DPR*us; CTX.font=`700 ${fs}px Inter`; const btnTextW=CTX.measureText(title).width;
          const bw=Math.max(160*DPR*us,Math.min(260*DPR*us,btnTextW+28*DPR*us)), bh=36*DPR*us;
          const rowH=isNarrow?(bh+32*DPR*us+22*DPR*us):56*DPR*us;
          CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,10*DPR*us,true,false);
          const bx=listX+12*DPR*us, by=y+10*DPR*us; drawButton(bx,by,bw,bh,title,true,true); addClick(bx,by,bw,bh,onClick);
          CTX.fillStyle=THEME.sub; CTX.font=`600 ${12*DPR*us}px Inter`; CTX.textAlign='left';
          if(isNarrow) CTX.fillText(desc,bx,by+bh+16*DPR*us); else {const dx=bx+bw+14*DPR*us, dy=y+rowH/2+4*DPR*us; CTX.textBaseline='middle'; CTX.fillText(desc,dx,dy);}
          y+=rowH+10*DPR*us;
        }
        row('Start Pulse Rush','Rapid orbs spawn. Click them for Bits and RP.',()=>startPulseRush());
        row('Start Timing Gate','Stop the marker in the zone with Space/click.',()=>startGate());
        row('Start Meteor Dodge+','Dodge meteors, shards & lasers.',()=>startMeteor());
      }

      if(state.tab==='Achievements'){
        const rows=[['First Pulse','Release a charged pulse once',state.lifetimeBits>0],['Collector','Own 30 modules total',state.modules.reduce((a,b)=>a+(b.count||0),0)>=30],['Researcher','Spend 200 RP',state.rpTotal>=200],['Arcader','Finish a minigame',state.arcadeLastRewarded]];
        for(const r of rows){const rowH=48*DPR; CTX.fillStyle=r[2]?'#14211a':'#121821'; roundRect(listX,y,listW,rowH,10*DPR,true,false); CTX.fillStyle=r[2]?'#e2f6e9':THEME.text; CTX.font=`800 ${14*DPR}px Inter`; CTX.textAlign='left'; CTX.textBaseline='middle'; CTX.fillText(r[0],listX+12*DPR,y+rowH/2-10*DPR); CTX.fillStyle=THEME.sub; CTX.font=`600 ${12*DPR}px Inter`; CTX.fillText(r[1],listX+12*DPR,y+rowH/2+10*DPR); y+=rowH+8*DPR;}
      }

      if(state.tab==='Stats'){
        const stats=[['Bits',fmt(state.bits)],['Lifetime Bits',fmt(state.lifetimeBits)],['PPS (base)',fmt(totalPPS()/(1+state.combo.v))],['PPS (with combo)',fmt(totalPPS())],['RP',fmt(state.rp)],['RP/s',fmt(rpPerSec())],['Modules',state.modules.reduce((a,b)=>a+(b.count||0),0).toString()],['Cores',fmt(state.ascend.cores)]];
        for(const [k,v] of stats){const rowH=40*DPR; CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,8*DPR,true,false); CTX.fillStyle='#a9b9cf'; CTX.font=`600 ${12*DPR}px Inter`; CTX.textAlign='left'; CTX.textBaseline='middle'; CTX.fillText(k,listX+12*DPR,y+rowH/2); CTX.textAlign='right'; CTX.fillStyle=THEME.text; CTX.font=`800 ${13*DPR}px Inter`; CTX.fillText(v,listX+listW-12*DPR,y+rowH/2); y+=rowH+8*DPR;}
      }

      if(state.tab==='Ascend'){
        const gain=coreGain(); const rowH=120*DPR; CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,10*DPR,true,false);
        CTX.fillStyle=THEME.text; CTX.font=`800 ${16*DPR}px Inter`; CTX.textAlign='left'; CTX.textBaseline='top'; CTX.fillText('Ascend resets progress for permanent Cores',listX+12*DPR,y+10*DPR);
        CTX.fillStyle=THEME.sub; CTX.font=`600 ${13*DPR}px Inter`; CTX.fillText(`You would gain: ${gain} cores (global x${(1+(state.ascend.cores+gain)*0.1).toFixed(2)})`,listX+12*DPR,y+32*DPR);
        const bw=160*DPR,bh=36*DPR; const bx=listX+listW-bw-12*DPR, by=y+rowH-bh-12*DPR; drawButton(bx,by,bw,bh,'Ascend (P)',gain>0,true); addClick(bx,by,bw,bh,()=>tryAscend());
      }

      if(state.tab==='Settings'){
        const items=[['Particles','particles'],['Low FX','lowFX'],['Mute (M)','mute'],['Export (E)','export'],['Import (I)','import'],['Reset Progress','reset']];
        for(const it of items){
          const rowH=44*DPR; CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,8*DPR,true,false);
          CTX.fillStyle=THEME.text; CTX.font=`700 ${13*DPR}px Inter`; CTX.textAlign='left'; CTX.textBaseline='middle'; CTX.fillText(it[0],listX+12*DPR,y+rowH/2);
          const bw=110*DPR,bh=30*DPR; const bx=listX+listW-bw-12*DPR, by=y+rowH/2-bh/2;
          if(it[1]==='export'){drawButton(bx,by,bw,bh,'Export',true,true);addClick(bx,by,bw,bh,()=>doExport());}
          else if(it[1]==='import'){drawButton(bx,by,bw,bh,'Import',true,true);addClick(bx,by,bw,bh,()=>doImport());}
          else if(it[1]==='reset'){drawButton(bx,by,bw,bh,'Reset',true,true);addClick(bx,by,bw,bh,resetProgress);}
          else{
            const key=it[1]; const val=state.settings[key];
            drawButton(bx,by,bw,bh,val?'ON':'OFF',true,val);
            addClick(bx,by,bw,bh,()=>{
              state.settings[key]=!state.settings[key];
              if(key==='particles'){
                state.cheat.taps = (state.cheat.taps||0) + 1;
                if(!state.cheat.unlocked && state.cheat.taps >= (state.cheat.req||50)){
                  state.cheat.unlocked = true; toast('Dev menu unlocked'); beep(1200,0.05,0.03,'square'); save();
                }
              }
            });
          }
          y+=rowH+8*DPR;
        }
        const rowH=60*DPR; CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,8*DPR,true,false);
        CTX.fillStyle=THEME.text; CTX.font=`700 ${13*DPR}px Inter`; CTX.textAlign='left'; CTX.textBaseline='top'; CTX.fillText('Buy Quantity ([-] / [=])',listX+12*DPR,y+10*DPR);
        const wBtn=70*DPR; let bx=listX+12*DPR; const by=y+rowH-38*DPR;
        BUY_QTY.forEach((q,i)=>{const on=i===state.buyQtyIndex; drawButton(bx,by,wBtn,28*DPR,q.toString(),true,on); addClick(bx,by,wBtn,28*DPR,()=>{state.buyQtyIndex=i;}); bx+=wBtn+8*DPR;});
      }

      if(state.tab==='Cheats' && state.cheat.unlocked){
        const us=state.ui.scale||1;
        function row(label,desc,fn){
          const rowH=56*DPR*us;
          CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,10*DPR*us,true,false);
          const bw=180*DPR*us, bh=34*DPR*us, bx=listX+12*DPR*us, by=y+rowH/2-bh/2;
          drawButton(bx,by,bw,bh,label,true,true); addClick(bx,by,bw,bh,fn);
          CTX.fillStyle=THEME.sub; CTX.font=`600 ${12*DPR*us}px Inter`; CTX.textAlign='left'; CTX.textBaseline='middle';
          CTX.fillText(desc, bx+bw+14*DPR*us, y+rowH/2);
          y+=rowH+10*DPR*us;
        }
        const cheatAddBits=(n)=>{ addBits(n); toast(`+${fmt(n)} bits`); };
        const cheatAddRP=(n)=>{ addRP(n); toast(`+${fmt(n)} RP`); };
        const cheatAddCores=(n)=>{ state.ascend.cores=Math.max(0,(state.ascend.cores||0)+n); state.ascend.best=Math.max(state.ascend.best,state.ascend.cores); toast(`Cores: ${state.ascend.cores}`); };
        const cheatToggleX10=()=>{ if(!state.cheat.x10){ mults.global *= 10; state.cheat.x10 = true; toast('Global x10 ON'); } else { mults.global /= 10; state.cheat.x10 = false; toast('Global x10 OFF'); } };
        const cheatUnlockAll=()=>{ for(const t of TECH){ if(!hasTech(t.id)){ state.tech.push(t.id); t.apply(); } } toast('All research unlocked'); };
        const cheatSpawnRift=()=>{ if(!state.rift.active){ state.rift.timer = 0; } };
        const cheatMaxModules=(cnt=100)=>{ for(const m of MODULES){ state.modules[m.id].count = cnt; } toast(`All modules set to ${cnt}`); };
        row('+10K Bits','Quick cash', ()=>cheatAddBits(1e4));
        row('+1M Bits','Bigger boost', ()=>cheatAddBits(1e6));
        row('+100 RP','Research points', ()=>cheatAddRP(100));
        row('+1 Core','Adds a core (perm bonus)', ()=>cheatAddCores(1));
        row('Global x10 (toggle)','Multiply global output', ()=>cheatToggleX10());
        row('Unlock All Research','Applies all tech', ()=>cheatUnlockAll());
        row('Spawn Rift','Triggers a rift', ()=>cheatSpawnRift());
        row('Max Modules (100)','Sets each module to 100', ()=>cheatMaxModules(100));
      }

      CTX.restore();

      state.ui.maxScroll = Math.max(0, (y + sOff) - (listY + listH));
      sOff = clamp(sOff, 0, state.ui.maxScroll);
      state.scroll[state.tab] = sOff;

      if(Math.abs(input.wheel)>0.1){ state.ui.scrollVel += input.wheel*0.6; input.wheel=0; }
      if(!state.ui.scrollDrag.active){
        if(Math.abs(state.ui.scrollVel)>0.1){
          sOff = clamp(sOff + state.ui.scrollVel, 0, state.ui.maxScroll);
          state.ui.scrollVel *= 0.86;
          state.scroll[state.tab]=sOff;
        }
      } else {
        state.ui.scrollVel *= 0.6;
      }
    }

    drawParticles();
    drawArcade();
    if(state.overlay.researchOpen){ drawResearch(); }
    drawToasts();
  }

  let saveAcc=0; function autoSave(dt){saveAcc+=dt;if(saveAcc>10){saveAcc=0;save();}}
  let last=nowMs(); function loop(){resize();const t=nowMs();let dt=(t-last)/1000;last=t;dt=clamp(dt,0,0.1);if(state.settings.lowFX)dt*=0.9;update(dt);draw(dt);autoSave(dt);prevDown=input.down;requestAnimationFrame(loop);} loop();
})();
</script>
</body>
</html>
