<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Quantum Forge</title>
<style>
  :root{ color-scheme: dark; }
  html,body{height:100%;margin:0;background:#090c10;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  canvas{display:block;position:fixed;inset:0;width:100%;height:100%}
  *{ -webkit-tap-highlight-color: transparent; user-select: none; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
(function(){
  'use strict';
  const CANVAS=document.getElementById('game');
  const CTX=CANVAS.getContext('2d',{alpha:false});
  let DPR=Math.max(1,Math.min(3,(window.devicePixelRatio||1)));

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const nowMs=()=>performance.now();
  const rand=(a,b)=>a+Math.random()*(b-a);
  const fmt=(n)=>{ if(!isFinite(n))return'∞'; if(n<1000)return n.toFixed(n<10?2:n<100?1:0);
    const U=['','K','M','B','T','Qa','Qi','Sx','Sp','Oc','No','Dc']; let i=0,x=n; while(x>=1000&&i<U.length-1){x/=1000;i++;} return x.toFixed(x<10?2:x<100?1:0)+U[i];
  };
  const measure=(txt,size,weight='600')=>{CTX.font=`${weight} ${size}px Inter,system-ui`;return CTX.measureText(txt).width;};

  function resize(){
    DPR=Math.max(1,Math.min(3,(window.devicePixelRatio||1)));
    const w=Math.max(320,Math.floor(CANVAS.clientWidth*DPR));
    const h=Math.max(320,Math.floor(CANVAS.clientHeight*DPR));
    if(CANVAS.width!==w||CANVAS.height!==h){CANVAS.width=w;CANVAS.height=h;}
  }
  window.addEventListener('resize',resize,{passive:true}); resize();

  const input={mx:0,my:0,down:false,wheel:0};
  let CLICK_EPS=6; // in CSS px, scaled by DPR each frame
  let prevDown=false;
  function canvasPos(evt){const r=CANVAS.getBoundingClientRect();return {x:(evt.clientX-r.left)*DPR,y:(evt.clientY-r.top)*DPR};}

  function onPointerMove(e){
    const p=canvasPos(e); input.mx=p.x; input.my=p.y;

    // Research overlay panning
    if((state.ui.researchOverlay && state.ui.researchOverlay.open) && state.ui.researchOverlay.pan.active){
      const pan=state.ui.researchOverlay.pan;
      const dx = input.mx - pan.lastX, dy = input.my - pan.lastY;
      const moved2 = dx*dx + dy*dy;
      const eps2 = (CLICK_EPS*DPR)*(CLICK_EPS*DPR);
      if(moved2 > eps2){
        state.ui.researchOverlay.camX += dx;
        state.ui.researchOverlay.camY += dy;
        pan.moved=true;
      }
      pan.lastX=input.mx; pan.lastY=input.my;
      return;
    }

    const dr=state.ui.scrollDrag;
    if(dr.active&&dr.tab===state.tab){
      const dy=input.my-dr.lastY; const max=state.ui.maxScroll||0;
      state.scroll[state.tab]=clamp((state.scroll[state.tab]||0)-dy,0,max);
      dr.vy=dy; dr.lastY=input.my;
    }
  }
  function onPointerDown(e){
    const p=canvasPos(e); input.mx=p.x; input.my=p.y; input.down=true;

    // If overlay open, begin panning and do not start sidebar drag
    if(state.ui.researchOverlay && state.ui.researchOverlay.open){
      state.ui.researchOverlay.pan={active:true,lastX:input.mx,lastY:input.my,moved:false};
      return;
    }

    const r=state.ui.sideRect;
    if(r && input.mx>=r.x && input.mx<=r.x+r.w && input.my>=r.y && input.my<=r.y+r.h){
      state.ui.scrollDrag={active:true,lastY:input.my,vy:0,tab:state.tab};
    }
  }
  function onPointerUp(e){
    const p=canvasPos(e); input.mx=p.x; input.my=p.y; input.down=false;

    if(state.ui.researchOverlay && state.ui.researchOverlay.open){
      const pan=state.ui.researchOverlay.pan||{moved:false,lastX:input.mx,lastY:input.my}; 
      const wasMoved = !!pan.moved;
      state.ui.researchOverlay.pan={active:false,lastX:0,lastY:0,moved:false};
      // Thresholded click
      if(!wasMoved) dispatchClick(p.x,p.y);
      return;
    }

    if(state.ui.scrollDrag.active){
      state.ui.scrollVel+=-state.ui.scrollDrag.vy*0.8;
      state.ui.scrollDrag={active:false,lastY:0,vy:0,tab:null};
    }
    dispatchClick(p.x,p.y);
  }
  if(window.PointerEvent){
    CANVAS.addEventListener('pointermove',onPointerMove);
    CANVAS.addEventListener('pointerdown',onPointerDown);
    CANVAS.addEventListener('pointerup',onPointerUp);
  }else{
    CANVAS.addEventListener('mousemove',e=>{const p=canvasPos(e);input.mx=p.x;input.my=p.y;});
    CANVAS.addEventListener('mousedown',onPointerDown);
    CANVAS.addEventListener('mouseup',onPointerUp);
    CANVAS.addEventListener('touchstart',e=>{const t=e.changedTouches[0];const r=CANVAS.getBoundingClientRect();input.mx=(t.clientX-r.left)*DPR;input.my=(t.clientY-r.top)*DPR;input.down=true;e.preventDefault();},{passive:false});
    CANVAS.addEventListener('touchend',e=>{const t=e.changedTouches[0];const r=CANVAS.getBoundingClientRect();const x=(t.clientX-r.left)*DPR,y=(t.clientY-r.top)*DPR;input.down=false;dispatchClick(x,y);},{passive:true});
  }
  CANVAS.addEventListener('wheel',e=>{input.wheel+=e.deltaY;},{passive:true});

  window.addEventListener('keydown',(e)=>{
    if(state.arcade.active){
      if(state.arcade.mode==='gate'&&(e.code==='Space'||e.key===' ')) gateStop();
      if(e.key==='Escape') endArcade();
      return;
    }
    // Close overlay with Escape
    if(state.ui.researchOverlay && state.ui.researchOverlay.open && e.key==='Escape'){ state.ui.researchOverlay.open=false; return; }

    if(e.key==='e'||e.key==='E') doExport();
    if(e.key==='i'||e.key==='I') doImport();
    if(e.key==='p'||e.key==='P') tryAscend();
    if(e.key==='m'||e.key==='M') state.settings.mute=!state.settings.mute;
    if(e.key==='-') cycleBuyQty(-1);
    if(e.key==='=') cycleBuyQty(+1);
    const idx='1234567890'.indexOf(e.key); if(idx!==-1) buyModule(idx);
  });

  let AC=null; function beep(f=420,d=0.05,v=0.02,type='triangle'){ if(state.settings.mute) return; try{ AC=AC||new (window.AudioContext||window.webkitAudioContext)(); const o=AC.createOscillator(),g=AC.createGain(); o.type=type;o.frequency.value=f;g.gain.value=v;o.connect(g);g.connect(AC.destination);o.start();o.stop(AC.currentTime+d);}catch{} }

  const MODULES=[
    {id:0,name:'Nanite Swarm', base:20,   mult:1.15, prod:0.14},
    {id:1,name:'Signal Printer', base:130, mult:1.15, prod:1.1},
    {id:2,name:'Biofarm',       base:1400, mult:1.15, prod:7.5},
    {id:3,name:'Ore Synth',     base:16000,mult:1.15, prod:44},
    {id:4,name:'Assembler',     base:175000,mult:1.15, prod:230},
    {id:5,name:'Credit Node',   base:1900000,mult:1.15, prod:1100},
    {id:6,name:'Research Lab',  base:26000000,mult:1.15, prod:6200, rp:0.06},
    {id:7,name:'Flux Shrine',   base:380000000,mult:1.15, prod:35000},
    {id:8,name:'Time Fork',     base:5500000000,mult:1.15, prod:210000},
    {id:9,name:'Singularity',   base:82000000000,mult:1.15, prod:1300000},
  ];

  const state={
    __version:3,
    bits:0,bitsTotal:0,lifetimeBits:0,
    rp:0,rpTotal:0,
    clickBase:1,clickMult:1,
    charge:{active:false,t:0,tMax:1.6},
    critZone:{lo:0.92,hi:1.0,mult:3},
    combo:{v:0,max:0.5,decay:0.12},
    modules:MODULES.map(m=>({id:m.id,count:0})),
    upgrades:[],tech:[],achievements:[],
    ascend:{cores:0,best:0},
    settings:{particles:true,mute:false,lowFX:false},
    lastSave:Date.now(),
    tab:'Forge',buyQtyIndex:0,
    scroll:{Forge:0,Shop:0,Research:0,Arcade:0,Achievements:0,Stats:0,Ascend:0,Settings:0},
    glitch:{next:rand(18,40),life:0,x:0,y:0,active:false,value:0},
    rift:{timer:rand(140,220),active:false,hp:0,hpMax:0,bitsReward:0,rpReward:0,prize:'bits',ttl:0,open:0,closing:false,wobble:0,stars:[]},
    particles:[],toast:[],
    arcade:{active:false,mode:null,t:0,score:0,pulses:[],gate:{x:0,v:0.9,zone:[0.45,0.55],tries:8}},
    clickArea:null,
    ui:{
      drawerOpen:false,scale:1,sideRect:null,maxScroll:0,
      scrollDrag:{active:false,lastY:0,vy:0,tab:null},scrollVel:0,
      researchOverlay:{open:false,camX:0,camY:0,hover:null,pan:{active:false,lastX:0,lastY:0,moved:false}}
    },
  };

  const mults={global:1,modules:1,glitch:1,combo:1};
  const mods={clickCurve:1,rpGain:1,arcadeReward:1,riftHP:1,gateZone:1,pulseSize:1,pulseLife:1};
  const BUY_QTY=[1,10,100,'Max'];

  const TECH=[
    {id:'t_over1',  name:'Overclock I',     rp:50,  pre:[],              apply:()=>{mults.global*=1.1;}, pos:[0,0],   desc:'+10% global'},
    {id:'t_curve',  name:'Harmonic Clicks', rp:25,  pre:[],              apply:()=>{mods.clickCurve*=1.5;}, pos:[-1,1], desc:'Pulses hit harder'},
    {id:'t_glitch', name:'Glitch Magnet',   rp:80,  pre:['t_over1'],     apply:()=>{mults.glitch*=1.5;}, pos:[1,1],   desc:'+50% Glitch Orbs'},
    {id:'t_combo',  name:'Flux Combo',      rp:150, pre:['t_curve'],     apply:()=>{state.combo.max=0.8; state.combo.decay=0.09;}, pos:[-1,2], desc:'Higher combo cap'},
    {id:'t_over2',  name:'Overclock II',    rp:200, pre:['t_over1'],     apply:()=>{mults.global*=1.2;}, pos:[0,2],   desc:'+20% global'},
    {id:'t_lab',    name:'Lab Protocols',   rp:120, pre:['t_over1'],     apply:()=>{mods.rpGain*=1.6;}, pos:[1,2],    desc:'+60% RP gain'},
    {id:'t_corecrit',name:'Widen Crit',     rp:200, pre:['t_curve'],     apply:()=>{state.critZone.lo=Math.max(0,state.critZone.lo-0.05); state.critZone.hi=Math.min(1,state.critZone.hi+0.02);}, pos:[-1,3], desc:'Wider crit arc'},
    {id:'t_over3',  name:'Overclock III',   rp:450, pre:['t_over2'],     apply:()=>{mults.global*=1.25;}, pos:[0,3],  desc:'+25% global'},
    {id:'t_riftdmp',name:'Rift Dampers',    rp:300, pre:['t_lab'],       apply:()=>{mods.riftHP*=0.8;}, pos:[1,3],    desc:'Rifts easier'},
    {id:'t_arcade', name:'Arcade Grants',   rp:260, pre:['t_lab'],       apply:()=>{mods.arcadeReward*=1.3;}, pos:[2,3], desc:'+30% arcade rewards'},
    {id:'t_combo2', name:'Combo Sustain',   rp:420, pre:['t_combo'],     apply:()=>{state.combo.decay=Math.max(0.05,state.combo.decay*0.7);}, pos:[-1,4], desc:'Slower combo decay'},
    {id:'t_mods',   name:'Module Eff.',     rp:600, pre:['t_over3'],     apply:()=>{mults.modules*=1.2;}, pos:[0,4],  desc:'+20% modules'},
    {id:'t_gate',   name:'Gate Precision',  rp:220, pre:['t_curve'],     apply:()=>{mods.gateZone*=1.25;}, pos:[-2,3], desc:'Easier Timing Gate'},
    {id:'t_pulse',  name:'Pulse Tuning',    rp:180, pre:['t_curve'],     apply:()=>{mods.pulseSize*=1.15; mods.pulseLife*=1.2;}, pos:[-2,2], desc:'Bigger, longer Pulse Rush'},
  ];


  function ensureDefaults(){
    // Make sure new UI keys exist even if an old save overwrote state.ui.
    state.ui = state.ui || {drawerOpen:false,scale:1,sideRect:null,maxScroll:0,scrollDrag:{active:false,lastY:0,vy:0,tab:null},scrollVel:0};
    if(!state.ui.researchOverlay){
      state.ui.researchOverlay = {open:false,camX:0,camY:0,hover:null,pan:{active:false,lastX:0,lastY:0,moved:false}};
    }
  }

  const SAVE_KEY=('quantum_forge_v3@'+(location.host||'local'));
  function save(){state.lastSave=Date.now();const data={...state,mults,mods};try{localStorage.setItem(SAVE_KEY,JSON.stringify(data));}catch{}}
  function load(){
    try{
      const raw=localStorage.getItem(SAVE_KEY); if(!raw) return; const d=JSON.parse(raw);
      const keep=['bits','bitsTotal','lifetimeBits','rp','rpTotal','clickBase','clickMult','charge','critZone','combo','modules','upgrades','tech','achievements','ascend','settings','lastSave','tab','buyQtyIndex','scroll','glitch','rift','particles','toast','arcade','clickArea','ui'];
      for(const k of keep){ if(k in d) state[k]=d[k]; }
      if(d.mults) Object.assign(mults,d.mults);
      if(d.mods) Object.assign(mods,d.mods);
      ensureDefaults();
      const secs=clamp((Date.now()-(d.lastSave||Date.now()))/1000,0,3600*8);
      const pps=totalPPS(); const off=pps*secs*0.75; if(off>0){ addBits(off); toast(`Offline +${fmt(off)} bits`); }
    }catch{}
  }
  load(); ensureDefaults();
  document.addEventListener('visibilitychange',()=>{if(document.hidden)save();},{passive:true});
  window.addEventListener('beforeunload',()=>{try{save();}catch{}});

  function count(id){return state.modules[id]?.count||0;}
  function moduleCost(id,n){const m=MODULES[id],c=count(id); if(n===1) return m.base*(m.mult**c); const r=m.mult; const base=m.base*(r**c); return base*((r**n-1)/(r-1));}
  function moduleProd(id){const m=MODULES[id]; return (m.prod||0)*mults.modules*mults.global*(1+state.ascend.cores*0.1);}
  function totalPPS(){let v=0;for(const m of MODULES){v+=count(m.id)*moduleProd(m.id);}return v*(1+state.combo.v);}
  function rpPerSec(){const lab=MODULES[6];const base=(lab.rp||0)*count(6);return base*mods.rpGain;}

  function clickValueFromCharge(){
    const q=state.charge.t/state.charge.tMax; const curve=(q*q)*mods.clickCurve;
    return state.clickBase*state.clickMult*curve*(1+state.ascend.cores*0.1)*mults.global;
  }

  function canAfford(x){return state.bits>=x;}
  function maxAffordable(id){const m=MODULES[id];const r=m.mult;const c=count(id);const base=m.base*(r**c); if(state.bits<base) return 0; const A=state.bits*(r-1)/base+1; const n=Math.floor(Math.log(A)/Math.log(r)); return Math.max(0,n);}
  function buyModule(id){const qty=BUY_QTY[state.buyQtyIndex]; let n=qty==='Max'?maxAffordable(id):qty; if(n<=0)return; const cost=moduleCost(id,n); if(!canAfford(cost))return; state.bits-=cost; state.modules[id].count+=n; beep(220+id*30,0.02,0.02);}
  function cycleBuyQty(d){state.buyQtyIndex=(state.buyQtyIndex+d+BUY_QTY.length)%BUY_QTY.length; toast(`Buy: ${BUY_QTY[state.buyQtyIndex]}`);}

  function addBits(v){if(!isFinite(v))return; state.bits+=v; state.bitsTotal+=v; state.lifetimeBits+=v;}
  function addRP(v){if(!isFinite(v))return; state.rp+=v; state.rpTotal+=v;}

  function hasTech(id){return state.tech.includes(id);}
  function techAvailable(t){return !hasTech(t.id)&&t.pre.every(p=>hasTech(p));}
  function buyTech(t){if(!techAvailable(t)||state.rp<t.rp)return; state.rp-=t.rp; state.tech.push(t.id); t.apply(); toast(`Researched: ${t.name}`); beep(760,0.05,0.03);}

  function coreGain(){return Math.floor(Math.sqrt(state.lifetimeBits/1e6));}
  function tryAscend(){
    const gain=coreGain(); if(gain<=0){toast('Generate more Bits to ascend');return;}
    state.ascend.cores+=gain; state.ascend.best=Math.max(state.ascend.best,state.ascend.cores);
    state.bits=0; state.bitsTotal=0; state.clickBase=1; state.clickMult=1; state.modules=MODULES.map(m=>({id:m.id,count:0})); state.upgrades=[]; state.rp=0; state.tech=[...state.tech];
    state.glitch={next:rand(18,40),life:0,x:0,y:0,active:false,value:0}; toast(`Ascended: +${gain} core(s) → global x${(1+state.ascend.cores*0.1).toFixed(2)})`); beep(880,0.07,0.03); save();
  }

  function updateGlitch(dt){
    const g=state.glitch;
    if(g.active){g.life-=dt; if(g.life<=0)g.active=false;}
    else{ g.next-=dt; if(g.next<=0){ g.active=true; g.life=10; g.x=rand(100,CANVAS.width-100); g.y=rand(120,CANVAS.height-160); g.value=(totalPPS()*rand(8,24)+clickValueFromCharge()*rand(20,60))*mults.glitch; g.next=rand(32,68);} }
  }
  function tryClickGlitch(px,py){
    const g=state.glitch; if(!g.active) return false;
    const d2=(px-g.x)**2+(py-g.y)**2; if(d2<=(28*DPR)**2){ addBits(g.value); g.active=false; particleBurst(g.x,g.y,18,'#ffd54a'); toast(`Glitch +${fmt(g.value)}`); beep(1200,0.06,0.04,'sawtooth'); return true; }
    return false;
  }

  function updateRift(dt){
    const r=state.rift;
    if(r.active){
      r.wobble+=dt;
      if(!r.closing&&r.open<1) r.open=Math.min(1,r.open+dt*1.8);
      if(r.closing){
        r.open=Math.max(0,r.open-dt*1.8);
        if(r.open<=0){r.active=false;r.closing=false;r.timer=rand(170,240);r.stars=[];}
      }
    }else{
      r.timer-=dt;
      if(r.timer<=0){
        r.active=true;r.open=0;r.closing=false;r.wobble=0;
        const pps=Math.max(1,totalPPS());
        r.hpMax=pps*rand(40,70)*mods.riftHP; r.hp=r.hpMax;
        r.bitsReward=pps*rand(80,160);
        r.rpReward=Math.max(5,pps*0.02*rand(20,40));
        r.prize=Math.random()<0.5?'bits':'rp';
        r.ttl=30; r.stars.length=0; for(let i=0;i<80;i++) r.stars.push({x:Math.random(),y:Math.random(),a:rand(0.5,1)});
        toast('A Rift tears reality! Spam click to seal it!');
      }
    }
  }
  function riftRect(){
    const UIS=state.ui.scale||1; const pad=16*DPR*UIS, headerH=64*DPR*UIS;
    const compact=(CANVAS.width/DPR)<980;
    const sidebarW=compact?(state.ui.drawerOpen?Math.min(320*DPR,CANVAS.width-2*pad):0):Math.max(340*DPR,CANVAS.width*0.30);
    const mainX=pad, mainY=pad*2+headerH; const mainW=CANVAS.width-sidebarW-pad*3; const mainH=CANVAS.height-mainY-pad;
    const yMid=mainY+mainH*0.45; const h=clamp(state.rift.open,0,1)*Math.max(60*DPR,mainH*0.25);
    return {x:mainX+12*DPR,yMid,w:mainW-24*DPR,h};
  }
  function tryClickRift(px,py){
    const r=state.rift; if(!r.active) return false; const area=riftRect();
    if(px>=area.x&&px<=area.x+area.w&&Math.abs(py-area.yMid)<=area.h/2){
      const dmg=Math.max(5,totalPPS()*0.8+10);
      r.hp=Math.max(0,r.hp-dmg);
      particleBurst(px,py,6,'#ff8fa3'); beep(980,0.02,0.02,'square');
      if(r.hp<=0&&!r.closing){
        r.closing=true;
        if(r.prize==='bits'){ addBits(r.bitsReward); toast(`Rift sealed! +${fmt(r.bitsReward)} bits`); }
        else { addRP(r.rpReward); toast(`Rift sealed! +${fmt(r.rpReward)} RP`); }
      }
      return true;
    }
    return false;
  }

  const clicks=[]; function addClick(x,y,w,h,onClick){clicks.push({x,y,w,h,onClick});} function hit(px,py,r){return px>=r.x&&px<=r.x+r.w&&py>=r.y&&py<=r.y+r.h;}
  function drawButton(x,y,w,h,label,on=true,accent=false){const r=10*DPR;CTX.save();CTX.fillStyle=on?(accent?'#2f3947':'#1a212b'):'#11161d';roundRect(x,y,w,h,r,true,false);CTX.fillStyle=on?'#e6eef6':'#7f8da0';CTX.font=`700 ${14*DPR}px Inter`;CTX.textAlign='center';CTX.textBaseline='middle';CTX.fillText(label,x+w/2,y+h/2);CTX.restore();}
  function drawBar(x,y,w,h,t,col='#4ade80'){CTX.fillStyle='#10151b';roundRect(x,y,w,h,h/2,true,false);CTX.fillStyle=col;roundRect(x,y,w*clamp(t,0,1),h,h/2,true,false);}
  function roundRect(x,y,w,h,r,fill,stroke){CTX.beginPath();CTX.moveTo(x+r,y);CTX.arcTo(x+w,y,x+w,y+h,r);CTX.arcTo(x+w,y+h,x,y+h,r);CTX.arcTo(x,y+h,x,y,r);CTX.arcTo(x,y,x+w,y,r);CTX.closePath();if(fill)CTX.fill();if(stroke)CTX.stroke();}
  function pill(x,y,txt){const fs=12*DPR,pad=6*DPR,w=measure(txt,fs,'700')*DPR+pad*2,h=20*DPR;CTX.fillStyle='#141a21';roundRect(x,y,w,h,999,true,false);CTX.fillStyle='#9fb0c6';CTX.font=`700 ${fs}px Inter`;CTX.textAlign='center';CTX.textBaseline='middle';CTX.fillText(txt,x+w/2,y+h/2);return{w,h};}
  function tooltip(x,y,lines){
    const fs=12*DPR; const pad=8*DPR;
    const w=Math.max(...lines.map(t=>measure(t,fs,'700')))*DPR + pad*2;
    const h=(fs+4*DPR)*lines.length + pad*2;
    let bx=x+14*DPR, by=y+14*DPR;
    if(bx+w>CANVAS.width-8*DPR) bx = x - w - 14*DPR;
    if(by+h>CANVAS.height-8*DPR) by = y - h - 14*DPR;
    CTX.fillStyle='#0c1117'; roundRect(bx,by,w,h,8*DPR,true,false);
    CTX.strokeStyle='#304256'; CTX.lineWidth=1*DPR; CTX.stroke();
    CTX.fillStyle='#e6eef6'; CTX.textAlign='left'; CTX.textBaseline='top'; CTX.font=`700 ${fs}px Inter`;
    let ty=by+pad; for(const t of lines){CTX.fillText(t,bx+pad,ty); ty+=fs+4*DPR;}
  }
  function toast(msg){state.toast.push({msg,t:2.6});}

  function particleBurst(x,y,n=12,color='#9be5ff'){for(let i=0;i<n;i++){state.particles.push({x,y,vx:rand(-120,120),vy:rand(-180,-40),life:rand(0.4,0.9),age:0,color});}}
  function updateParticles(dt){for(let i=state.particles.length-1;i>=0;i--){const p=state.particles[i];p.age+=dt;p.x+=p.vx*dt;p.y+=p.vy*dt;p.vy+=220*dt;if(p.age>p.life)state.particles.splice(i,1);}}
  function drawParticles(){for(const p of state.particles){const t=1-p.age/p.life;CTX.globalAlpha=Math.max(0,t);CTX.fillStyle=p.color;CTX.fillRect(p.x,p.y,3*DPR,3*DPR);CTX.globalAlpha=1;}}
  function updateToasts(dt){for(let i=state.toast.length-1;i>=0;i--){const t=state.toast[i];t.t-=dt;if(t.t<=0)state.toast.splice(i,1);}}
  function drawToasts(){const fs=12*DPR;CTX.font=`700 ${fs}px Inter`;CTX.textAlign='center';let y=20*DPR;for(const t of state.toast){CTX.fillStyle='#0f141a';const w=measure(t.msg,fs,'700')*DPR+26*DPR;const h=24*DPR;const x=CANVAS.width/2-w/2;roundRect(x,y,w,h,10*DPR,true,false);CTX.fillStyle='#e6eef6';CTX.fillText(t.msg,CANVAS.width/2,y+h/2);y+=h+8*DPR;}}

  function updateCharge(dt){
    const area=state.clickArea; if(!area) return;
    const inside=((input.mx-area.cx)**2+(input.my-area.cy)**2)<=area.R*area.R;
    if(input.down&&!prevDown&&inside){state.charge.active=true;}
    if(state.charge.active){
      if(input.down){
        state.charge.t=clamp(state.charge.t+dt*(1+(hasTech('t_over1')?0.15:0)),0,state.charge.tMax);
      }else{
        const base=clickValueFromCharge();
        const q=state.charge.t/state.charge.tMax; const inCrit=q>=state.critZone.lo&&q<=state.critZone.hi; const val=base*(inCrit?state.critZone.mult:1);
        addBits(val); particleBurst(input.mx,input.my,inCrit?18:10,inCrit?'#9be5ff':'#c7d2fe'); beep(inCrit?820:520,inCrit?0.06:0.03,0.03);
        state.combo.v=clamp(state.combo.v+q*0.12,0,state.combo.max);
        addRP(q*0.4*mods.rpGain);
        state.charge.active=false; state.charge.t=0;
      }
    }
    if(!input.down){state.charge.active=false;}
  }

  // Arcade
  function startPulseRush(){
    state.arcade.active=true; state.arcade.mode='pulse'; state.arcade.t=25; state.arcade.score=0; state.arcade.pulses=[];
    state.arcade.pulse={spawn:0.65,life:2.4*mods.pulseLife,rMin:22*mods.pulseSize,rMax:42*mods.pulseSize,maxOnScreen:8};
    toast('Pulse Rush: click the orbs!');
  }
  function startGate(){
    state.arcade.active=true; state.arcade.mode='gate'; state.arcade.t=30; state.arcade.score=0;
    const w=0.10*mods.gateZone; state.arcade.gate={x:0.0,v:0.9,zone:[0.5-w/2,0.5+w/2],tries:8}; toast('Timing Gate: press Space or click');
  }
  function startMeteor(){
    state.arcade.active=true; state.arcade.mode='meteor'; state.arcade.t=28; state.arcade.score=0;
    // Hazards: rocks, comets (tamed), mines->shards, sweeping beams
    const speed=300*DPR;
    state.arcade.meteor={
      px:CANVAS.width/2, py:CANVAS.height*0.65, r:14*DPR,
      rocks:[], comets:[], mines:[], shards:[], beams:[], stars:[],
      spawn:{rock:7.5, comet:1.2, mine:1.4, beam:0.55, star:0.55},
      speed
    };
    toast('Meteor Dodge+: full send.');
  }
  function endArcade(){
    if(!state.arcade.active) return;
    const s=Math.max(0,Math.floor(state.arcade.score)); const mode=state.arcade.mode; state.arcade.active=false;
    let bits=0,rp=0;
    if(mode==='pulse'){bits=s*3;rp=s*0.3;}
    else if(mode==='gate'){bits=s*8;rp=s*0.6;}
    else if(mode==='meteor'){bits=s*6;rp=s*0.45;}
    bits*=mods.arcadeReward; rp*=mods.arcadeReward;
    if(bits||rp){addBits(bits);addRP(rp);toast(`Arcade reward: +${fmt(bits)} bits, +${fmt(rp)} RP`);}
  }

  function spawnBeam(M){
    const horizontal=Math.random()<0.5;
    if(horizontal){
      const y=rand(120*DPR, CANVAS.height-120*DPR);
      M.beams.push({dir:'h',pos:y,phase:'warn',t:0.75,fire:1.10,th:28*DPR});
    }else{
      const x=rand(80*DPR, CANVAS.width-80*DPR);
      M.beams.push({dir:'v',pos:x,phase:'warn',t:0.75,fire:1.10,th:28*DPR});
    }
  }

  function updateArcade(dt){
    if(!state.arcade.active) return;
    const A=state.arcade; A.t-=dt; if(A.t<=0){endArcade();return;}

    if(A.mode==='pulse'){
      const conf=A.pulse; if(A.pulses.length<conf.maxOnScreen&&Math.random()<dt*conf.spawn){const life=conf.life;A.pulses.push({x:rand(120,CANVAS.width-120),y:rand(160,CANVAS.height-160),life,max:life});}
      for(let i=A.pulses.length-1;i>=0;i--){const p=A.pulses[i];p.life-=dt;if(p.life<=0)A.pulses.splice(i,1);}

    }else if(A.mode==='gate'){
      const g=A.gate; g.x+=g.v*dt; if(g.x<0){g.x=0;g.v=Math.abs(g.v);} if(g.x>1){g.x=1;g.v=-Math.abs(g.v);}

    }else if(A.mode==='meteor'){
      const M=A.meteor; M.px=input.mx; M.py=input.my; A.score+=dt*3.0;

      // Spawns
      if(Math.random()<dt*M.spawn.rock) M.rocks.push({x:rand(30,CANVAS.width-30),y:-30*DPR,r:rand(22,52)*DPR,vy:rand(1.2,1.8)*M.speed});
      if(Math.random()<dt*M.spawn.comet){
        const side=Math.floor(rand(0,4)); // 0 top,1 left,2 right,3 top offset
        let x=rand(20,CANVAS.width-20), y=-40*DPR, vx=0, vy=rand(1.05,1.45)*M.speed;
        if(side===1){ x=-40*DPR; y=rand(60,CANVAS.height*0.6); vx=rand(0.75,1.0)*M.speed; vy=rand(0.25,0.6)*M.speed; }
        if(side===2){ x=CANVAS.width+40*DPR; y=rand(60,CANVAS.height*0.6); vx=-rand(0.75,1.0)*M.speed; vy=rand(0.25,0.6)*M.speed; }
        M.comets.push({x,y,r:rand(16,26)*DPR,vx,vy,homing:0.008,drift:rand(-0.35,0.35)});
      }
      if(Math.random()<dt*M.spawn.mine) M.mines.push({x:rand(40,CANVAS.width-40),y:-20*DPR,r:16*DPR,vy:rand(0.8,1.1)*M.speed,t:2.4}); // fuse
      if(Math.random()<dt*M.spawn.beam) spawnBeam(M);
      if(Math.random()<dt*M.spawn.star) M.stars.push({x:rand(40,CANVAS.width-40),y:-10*DPR,r:8*DPR,vy:rand(0.9,1.2)*M.speed});

      // Update rocks
      for(let i=M.rocks.length-1;i>=0;i--){const k=M.rocks[i];k.y+=k.vy*dt;if(k.y>CANVAS.height+80*DPR)M.rocks.splice(i,1);}

      // Update comets (gentle homing + drift wobble)
      for(let i=M.comets.length-1;i>=0;i--){
        const c=M.comets[i];
        const ang=Math.atan2(M.py-c.y, M.px-c.x) + c.drift*0.15*Math.sin(performance.now()/600 + i);
        const sp=Math.hypot(c.vx,c.vy)||M.speed*0.9;
        const tx=Math.cos(ang)*sp, ty=Math.sin(ang)*sp;
        c.vx=lerp(c.vx,tx,c.homing);  // tiny adjustment
        c.vy=lerp(c.vy,ty,c.homing);
        c.x+=c.vx*dt; c.y+=c.vy*dt;
        if(c.x<-120*DPR||c.x>CANVAS.width+120*DPR||c.y>CANVAS.height+120*DPR) M.comets.splice(i,1);
      }

      // Update mines -> explode into shards
      for(let i=M.mines.length-1;i>=0;i--){
        const m=M.mines[i]; m.y+=m.vy*dt; m.t-=dt;
        if(m.t<=0 || m.y>CANVAS.height-40*DPR){
          // explode
          const N=10; const speed=rand(220,320)*DPR;
          for(let j=0;j<N;j++){const a=(Math.PI*2)*j/N + rand(-0.2,0.2); M.shards.push({x:m.x,y:m.y,r:6*DPR,vx:Math.cos(a)*speed,vy:Math.sin(a)*speed,life:1.6});}
          particleBurst(m.x,m.y,12,'#ffcf88'); M.mines.splice(i,1); beep(520,0.05,0.03,'square');
        } else if(m.y>CANVAS.height+40*DPR){ M.mines.splice(i,1); }
      }
      for(let i=M.shards.length-1;i>=0;i--){
        const s=M.shards[i]; s.x+=s.vx*dt; s.y+=s.vy*dt; s.life-=dt;
        if(s.x<-60*DPR||s.x>CANVAS.width+60*DPR||s.y<-60*DPR||s.y>CANVAS.height+60*DPR||s.life<=0) M.shards.splice(i,1);
      }

      // Update beams
      for(let i=M.beams.length-1;i>=0;i--){
        const b=M.beams[i];
        b.t-=dt;
        if(b.phase==='warn' && b.t<=0){ b.phase='fire'; b.t=b.fire; }
        else if(b.phase==='fire' && b.t<=0){ M.beams.splice(i,1); }
      }

      // Update stars
      for(let i=M.stars.length-1;i>=0;i--){const k=M.stars[i];k.y+=k.vy*dt;if(k.y>CANVAS.height+30*DPR)M.stars.splice(i,1);}

      // Collisions
      const pr=M.r;
      function hitCircle(cx,cy,cr){const d2=(cx-M.px)**2+(cy-M.py)**2; return d2<=(cr+pr)**2; }
      function penalize(amount=3){ A.score=Math.max(0,A.score-amount); beep(260,0.04,0.03,'sine'); particleBurst(M.px,M.py,8,'#ff9aa2'); }

      for(let i=M.rocks.length-1;i>=0;i--){const k=M.rocks[i]; if(hitCircle(k.x,k.y,k.r)){ penalize(3); M.rocks.splice(i,1);}}
      for(let i=M.comets.length-1;i>=0;i--){const k=M.comets[i]; if(hitCircle(k.x,k.y,k.r)){ penalize(3); M.comets.splice(i,1);}}
      for(let i=M.mines.length-1;i>=0;i--){const k=M.mines[i]; if(hitCircle(k.x,k.y,k.r*1.1)){ penalize(4); k.t=0; /* force explode next loop */ }}
      for(let i=M.shards.length-1;i>=0;i--){const k=M.shards[i]; if(hitCircle(k.x,k.y,k.r)){ penalize(2.5); M.shards.splice(i,1);}}

      // Beam collision
      for(const b of M.beams){
        if(b.phase!=='fire') continue;
        if(b.dir==='h'){
          const y=b.pos, half=b.th/2;
          if(M.py>y-half && M.py<y+half){ penalize(6); }
        }else{
          const x=b.pos, half=b.th/2;
          if(M.px>x-half && M.px<x+half){ penalize(6); }
        }
      }

      // Star collect
      for(let i=M.stars.length-1;i>=0;i--){const k=M.stars[i]; if(hitCircle(k.x,k.y,k.r)){ A.score+=3; addRP(0.5*mods.rpGain); beep(900,0.03,0.02,'triangle'); particleBurst(k.x,k.y,6,'#a7f3d0'); M.stars.splice(i,1);}}
    }
  }

  function drawArcade(){
    if(!state.arcade.active) return;
    const A=state.arcade;
    CTX.globalAlpha=0.85;CTX.fillStyle='#000';CTX.fillRect(0,0,CANVAS.width,CANVAS.height);CTX.globalAlpha=1;
    const title=A.mode==='pulse'?'Pulse Rush':A.mode==='gate'?'Timing Gate':A.mode==='meteor'?'Meteor Dodge+':'Arcade';
    CTX.fillStyle='#e6eef6';CTX.font=`800 ${18*DPR}px Inter`;CTX.textAlign='center';CTX.fillText(`${title} — ${A.t.toFixed(1)}s`,CANVAS.width/2,60*DPR);
    if(A.mode==='pulse'){
      const conf=A.pulse; for(const p of A.pulses){const t=p.life/p.max; const r=lerp(conf.rMin*DPR,conf.rMax*DPR,t); CTX.globalAlpha=Math.max(0.2,t); CTX.fillStyle='#8be9fd'; CTX.beginPath(); CTX.arc(p.x,p.y,r,0,Math.PI*2); CTX.fill(); CTX.globalAlpha=1;}
      CTX.fillStyle='#9fb0c6';CTX.font=`700 ${14*DPR}px Inter`;CTX.fillText(`Score: ${Math.floor(A.score)}`,CANVAS.width/2,90*DPR);
    }else if(A.mode==='gate'){
      const cx=CANVAS.width/2,y=CANVAS.height/2,W=520*DPR,H=22*DPR; CTX.fillStyle='#121821'; roundRect(cx-W/2,y-H/2,W,H,10*DPR,true,false);
      const [zl,zh]=A.gate.zone; CTX.fillStyle='#284b63'; roundRect(cx-W/2+W*zl,y-H/2,W*(zh-zl),H,10*DPR,true,false);
      const mx=cx-W/2+W*A.gate.x; CTX.fillStyle='#e6eef6'; roundRect(mx-5*DPR,y-10*DPR,10*DPR,20*DPR,3*DPR,true,false);
      CTX.fillStyle='#9fb0c6';CTX.font=`700 ${14*DPR}px Inter`; CTX.fillText(`Tries: ${A.gate.tries}  Score: ${A.score}`,cx,y+40*DPR); CTX.fillText(`Press Space OR Click the bar`,cx,y+62*DPR);
    }else if(A.mode==='meteor'){
      const M=A.meteor;

      // Beams
      for(const b of M.beams){
        if(b.phase==='warn'){
          CTX.globalAlpha=0.5+0.5*Math.sin(performance.now()/120);
          CTX.fillStyle='#314256';
          if(b.dir==='h') roundRect(0,b.pos-3*DPR,CANVAS.width,6*DPR,3*DPR,true,false);
          else roundRect(b.pos-3*DPR,0,6*DPR,CANVAS.height,3*DPR,true,false);
          CTX.globalAlpha=1;
        }else{
          CTX.globalAlpha=0.9;
          CTX.fillStyle='#c33';
          if(b.dir==='h') roundRect(0,b.pos-b.th/2,CANVAS.width,b.th,6*DPR,true,false);
          else roundRect(b.pos-b.th/2,0,b.th,CANVAS.height,6*DPR,true,false);
          CTX.globalAlpha=1;
        }
      }

      // Rocks
      for(const k of M.rocks){CTX.fillStyle='#394553';CTX.beginPath();CTX.arc(k.x,k.y,k.r,0,Math.PI*2);CTX.fill();}
      // Comets
      for(const c of M.comets){
        CTX.fillStyle='#b8d7ff';
        CTX.beginPath();CTX.arc(c.x,c.y,c.r,0,Math.PI*2);CTX.fill();
        CTX.globalAlpha=0.5; CTX.strokeStyle='#7aa5d8'; CTX.lineWidth=4*DPR;
        CTX.beginPath(); CTX.moveTo(c.x,c.y); CTX.lineTo(c.x - c.vx*0.05, c.y - c.vy*0.05); CTX.stroke(); CTX.globalAlpha=1;
      }
      // Mines
      for(const m of M.mines){
        const pct=clamp(1-m.t/2.4,0,1);
        CTX.fillStyle='#2d3744'; CTX.beginPath(); CTX.arc(m.x,m.y,m.r,0,Math.PI*2); CTX.fill();
        CTX.strokeStyle='#ffd28a'; CTX.globalAlpha=0.3+0.7*pct; CTX.lineWidth=2*DPR;
        CTX.beginPath(); CTX.arc(m.x,m.y,m.r+6*DPR*Math.sin(performance.now()/150),0,Math.PI*2); CTX.stroke(); CTX.globalAlpha=1;
      }
      // Shards
      for(const s of M.shards){CTX.fillStyle='#ffb38a'; CTX.beginPath(); CTX.arc(s.x,s.y,s.r,0,Math.PI*2); CTX.fill();}
      // Stars
      for(const s of M.stars){CTX.fillStyle='#9be7d7';CTX.beginPath();CTX.arc(s.x,s.y,s.r,0,Math.PI*2);CTX.fill();}

      // Player
      CTX.fillStyle='#e6eef6';CTX.beginPath();CTX.arc(M.px,M.py,M.r,0,Math.PI*2);CTX.fill();
      CTX.fillStyle='#9fb0c6';CTX.font=`700 ${14*DPR}px Inter`;CTX.fillText(`Score: ${Math.floor(A.score)}`,CANVAS.width/2,90*DPR);
    }
  }

  function drawResearchOverlay(){
    if(!(state.ui.researchOverlay && state.ui.researchOverlay.open)) return;
    const O=state.ui.researchOverlay;

    // Dim background
    CTX.globalAlpha=0.9; CTX.fillStyle='#03060a'; CTX.fillRect(0,0,CANVAS.width,CANVAS.height); CTX.globalAlpha=1;

    // Compute bounds and unit so whole tree fits
    const xs=TECH.map(t=>t.pos[0]), ys=TECH.map(t=>t.pos[1]);
    const minX=Math.min(...xs), maxX=Math.max(...xs), minY=Math.min(...ys), maxY=Math.max(...ys);
    const pad=160*DPR;
    const wUnits=(maxX-minX)||1, hUnits=(maxY-minY)||1;
    const unitRaw=Math.min((CANVAS.width-pad*2)/wUnits,(CANVAS.height-pad*2)/hUnits);
    const unit=Math.min(Math.max(unitRaw,80*DPR),180*DPR);

    // Center camera if first open (cam at 0,0 means centered)
    // Transform world->screen
    function toScreen(px,py){
      const cx=CANVAS.width/2 + O.camX;
      const cy=CANVAS.height/2 + O.camY;
      // Offset by mid to center the tree
      const midX=(minX+maxX)/2, midY=(minY+maxY)/2;
      const x=cx + (px-midX)*unit;
      const y=cy + (py-midY)*unit;
      return {x,y};
    }

    // Title & Close button
    CTX.fillStyle='#e6eef6'; CTX.font=`800 ${18*DPR}px Inter`; CTX.textAlign='left'; CTX.fillText('Research Tree — drag to pan • hover nodes for details • click to research',20*DPR,28*DPR);
    const closeW=44*DPR, closeH=32*DPR; const cbx=CANVAS.width-closeW-18*DPR, cby=18*DPR;
    drawButton(cbx,cby,closeW,closeH,'✕',true,true); addClick(cbx,cby,closeW,closeH,()=>{O.open=false;});

    // Edges
    for(const t of TECH){
      for(const p of t.pre){
        const tp=TECH.find(x=>x.id===p);
        const a=toScreen(tp.pos[0],tp.pos[1]);
        const b=toScreen(t.pos[0],t.pos[1]);
        CTX.strokeStyle='#223142'; CTX.lineWidth=2*DPR; CTX.beginPath(); CTX.moveTo(a.x,a.y); CTX.lineTo(b.x,b.y); CTX.stroke();
      }
    }

    // Nodes
    O.hover=null;
    const r=22*DPR;
    for(const t of TECH){
      const s=toScreen(t.pos[0],t.pos[1]);
      const owned=hasTech(t.id); const avail=techAvailable(t)&&state.rp>=t.rp;
      CTX.fillStyle=owned?'#1f3427':(avail?'#1f2631':'#11161d'); CTX.beginPath(); CTX.arc(s.x,s.y,r,0,Math.PI*2); CTX.fill();
      CTX.strokeStyle=avail?'#7fd1ff':'#2a3949'; CTX.lineWidth=2*DPR; CTX.stroke();
      CTX.fillStyle=owned?'#c8f7da':'#e6eef6'; CTX.font=`700 ${12*DPR}px Inter`; CTX.textAlign='center'; CTX.textBaseline='bottom'; CTX.fillText(t.name,s.x,s.y-r-10*DPR);
      CTX.fillStyle='#9fb0c6'; CTX.font=`600 ${11*DPR}px Inter`; CTX.textBaseline='top'; CTX.fillText(`${t.rp} RP`,s.x,s.y+r+6*DPR);
      // Hover detect
      const d2=(input.mx-s.x)**2+(input.my-s.y)**2;
      if(d2<=r*r) O.hover=t;
      // Click to research
      addClick(s.x-r,s.y-r,r*2,r*2,()=>{ if(techAvailable(t)){ buyTech(t); } });
    }

    // Tooltip
    if(O.hover){
      const t=O.hover; const owned=hasTech(t.id); const avail=techAvailable(t)&&state.rp>=t.rp;
      const status=owned?'Owned':(avail?'Available':'Locked');
      const lines=[t.name, t.desc, `Cost: ${t.rp} RP • ${status}`];
      tooltip(input.mx,input.my,lines);
    }
  }

  function gateStop(){
    const A=state.arcade; if(!A.active||A.mode!=='gate'||A.gate.tries<=0) return; const g=A.gate; A.gate.tries--;
    const inside=(g.x>=g.zone[0]&&g.x<=g.zone[1]);
    if(inside){A.score++;const mid=(g.zone[0]+g.zone[1])/2;if(Math.abs(g.x-mid)<=(g.zone[1]-g.zone[0])*0.15){A.score++;toast('Perfect! +Bonus');}addRP(1.2*mods.rpGain);addBits(8);beep(880,0.05,0.02,'sine');}
    else{beep(260,0.05,0.02,'sine');}
    if(A.gate.tries<=0) endArcade();
  }

  function update(dt){
    addBits(totalPPS()*dt); addRP(rpPerSec()*dt);
    state.combo.v=clamp(state.combo.v-state.combo.decay*dt,0,state.combo.max);
    updateGlitch(dt); updateRift(dt); updateArcade(dt); updateCharge(dt); updateParticles(dt); updateToasts(dt);
  }

  function draw(dt){
    clicks.length=0; CTX.clearRect(0,0,CANVAS.width,CANVAS.height);
    const g=CTX.createLinearGradient(0,0,0,CANVAS.height); g.addColorStop(0,'#0a0e13'); g.addColorStop(1,'#0a0e13'); CTX.fillStyle=g; CTX.fillRect(0,0,CANVAS.width,CANVAS.height);

    const UIS=clamp(Math.min(CANVAS.width/(1280*DPR),CANVAS.height/(720*DPR)),0.8,1.15);
    state.ui.scale=UIS;
    const pad=16*DPR*UIS, headerH=64*DPR*UIS; const compact=(CANVAS.width/DPR)<980;
    let sidebarW=compact?(state.ui.drawerOpen?Math.min(320*DPR,CANVAS.width-2*pad):0):Math.max(340*DPR,CANVAS.width*0.30);

    CTX.fillStyle='#0f1318'; roundRect(pad,pad,CANVAS.width-pad*2,headerH,14*DPR,true,false);
    CTX.fillStyle='#e6eef6'; CTX.font=`800 ${20*DPR*state.ui.scale}px Inter`; CTX.textAlign='left'; CTX.textBaseline='middle'; CTX.fillText('Quantum Forge',pad*2,pad+headerH/2);
    let xr=CANVAS.width-pad*2-100*DPR; pill(xr,pad+headerH/2-10*DPR,`Buy: ${BUY_QTY[state.buyQtyIndex]}`); addClick(xr,pad+headerH/2-10*DPR,100*DPR,20*DPR,()=>cycleBuyQty(+1));
    xr-=150*DPR; pill(xr,pad+headerH/2-10*DPR,`Cores: ${fmt(state.ascend.cores)} (x${(1+state.ascend.cores*0.1).toFixed(2)})`);
    if(compact){
      const bw=36*DPR,bh=32*DPR; const bx=CANVAS.width-pad-bw, by=pad+headerH/2-bh/2;
      drawButton(bx,by,bw,bh,state.ui.drawerOpen?'✕':'≡',true,true); addClick(bx,by,bw,bh,()=>{state.ui.drawerOpen=!state.ui.drawerOpen;});
    }

    const mainX=pad, mainY=pad*2+headerH; const mainW=CANVAS.width-sidebarW-pad*3; const mainH=CANVAS.height-mainY-pad;
    const sideX=CANVAS.width-sidebarW-pad, sideY=mainY, sideH=mainH;

    CTX.fillStyle='#0f141a'; roundRect(mainX,mainY,mainW,mainH,16*DPR,true,false);

    (function(){
      const padHUD=10*DPR*UIS, f1=(16*UIS)*DPR, f2=(12*UIS)*DPR;
      const l1=`Bits: ${fmt(state.bits)}`, l2=`PPS: ${fmt(totalPPS())}   RP: ${fmt(state.rp)}`;
      CTX.font=`800 ${f1}px Inter`; const w1=CTX.measureText(l1).width; CTX.font=`700 ${f2}px Inter`; const w2=CTX.measureText(l2).width;
      const w=Math.max(w1,w2)+padHUD*2, h=f1+f2+padHUD*3, bx=mainX+(mainW-w)/2, by=mainY+8*DPR;
      CTX.fillStyle='#0b1117'; roundRect(bx,by,w,h,10*DPR,true,false);
      CTX.fillStyle='#e6eef6'; CTX.font=`800 ${f1}px Inter`; CTX.textAlign='center'; CTX.textBaseline='top'; CTX.fillText(l1,bx+w/2,by+padHUD*0.8);
      CTX.fillStyle='#b6c6da'; CTX.font=`700 ${f2}px Inter`; CTX.fillText(l2,bx+w/2,by+padHUD*0.8+f1+6*DPR);
    })();

    const cx=mainX+mainW*0.5, cy=mainY+mainH*(compact?0.60:0.58); const R=Math.min(mainW,mainH)*(compact?0.28:0.32);
    state.clickArea={cx,cy,R};
    CTX.save(); CTX.shadowBlur=36*DPR; CTX.shadowColor='#213141'; CTX.fillStyle='#16202b'; CTX.beginPath(); CTX.arc(cx,cy,R,0,Math.PI*2); CTX.fill(); CTX.restore();
    const q=state.charge.t/state.charge.tMax; CTX.lineWidth=8*DPR; CTX.strokeStyle='#2d4156'; CTX.beginPath(); CTX.arc(cx,cy,R-14*DPR,-Math.PI/2,-Math.PI/2+Math.PI*2*q); CTX.stroke();
    const a1=-Math.PI/2+Math.PI*2*state.critZone.lo, a2=-Math.PI/2+Math.PI*2*state.critZone.hi; CTX.strokeStyle='#86e7ff'; CTX.lineWidth=6*DPR; CTX.beginPath(); CTX.arc(cx,cy,R-18*DPR,a1,a2); CTX.stroke();
    CTX.fillStyle='#e6eef6'; CTX.font=`800 ${22*DPR}px Inter`; CTX.textAlign='center'; CTX.textBaseline='middle'; CTX.fillText(state.charge.active?'RELEASE':'HOLD',cx,cy);

    if(state.glitch.active){const t=(Math.sin(performance.now()/180)+1)/2;CTX.save();CTX.translate(state.glitch.x,state.glitch.y);CTX.rotate(t*0.3);CTX.fillStyle='#ffd54a';CTX.beginPath();CTX.arc(0,0,16*DPR,0,Math.PI*2);CTX.fill();CTX.fillStyle='#7a5600';CTX.beginPath();CTX.arc(-5*DPR,-2*DPR,2.5*DPR,0,Math.PI*2);CTX.fill();CTX.restore();addClick(state.glitch.x-18*DPR,state.glitch.y-18*DPR,36*DPR,36*DPR,(px,py)=>{tryClickGlitch(px,py);});}

    if(state.rift.active){
      const r=state.rift, rect=riftRect(), x=rect.x, w=rect.w, yMid=rect.yMid, h=rect.h;
      CTX.save(); CTX.globalAlpha=0.5*r.open; CTX.fillStyle='#000'; CTX.fillRect(0,0,CANVAS.width,CANVAS.height); CTX.globalAlpha=1;
      CTX.beginPath(); const segs=16, amp=8*DPR*r.open; let xx,yy;
      CTX.moveTo(x,yMid-h/2);
      for(let i=1;i<=segs;i++){const t=i/segs;xx=x+w*t;yy=yMid-h/2+Math.sin((t*10+r.wobble*2))*amp;CTX.lineTo(xx,yy);}
      for(let i=segs;i>=0;i--){const t=i/segs;xx=x+w*t;yy=yMid+h/2+Math.sin((t*10+r.wobble*2+Math.PI))*amp;CTX.lineTo(xx,yy);}
      CTX.closePath(); CTX.fillStyle='#0a0b12'; CTX.fill();
      for(const s of r.stars){const sx=x+s.x*w, sy=yMid-h/2+s.y*h; CTX.globalAlpha=s.a; CTX.fillStyle='#8dd3ff'; CTX.fillRect(sx,sy,2*DPR,2*DPR);} CTX.globalAlpha=1;
      CTX.strokeStyle='#1f2a3a'; CTX.lineWidth=2*DPR; CTX.stroke();
      CTX.fillStyle='#e6eef6'; CTX.font=`800 ${16*DPR}px Inter`; CTX.textAlign='center'; CTX.fillText('RIFT! SPAM-CLICK!',x+w/2,yMid-h/2-28*DPR);
      const barW=Math.min(w*0.7,520*DPR), barH=16*DPR, bx=x+(w-barW)/2, by=yMid+h/2+12*DPR; drawBar(bx,by,barW,barH,1-r.hp/r.hpMax,'#ef4444');
      CTX.fillStyle='#9fb0c6'; CTX.font=`700 ${12*DPR}px Inter`; const prizeTxt=r.prize==='bits'?`Reward: ${fmt(r.bitsReward)} bits`:`Reward: ${fmt(r.rpReward)} RP`; CTX.fillText(prizeTxt,x+w/2,by+barH+16*DPR);
      CTX.restore();
    }

    if(sidebarW>0){
      CTX.fillStyle='#0f141a'; roundRect(sideX,sideY,sidebarW,sideH,16*DPR,true,false);
      const tabs=['Forge','Shop','Research','Arcade','Achievements','Stats','Ascend','Settings'];
      const tabH=40*DPR; let tx=sideX; const tw=sidebarW/tabs.length; const tabFs=tw<90*DPR?11*DPR:13*DPR;
      for(const tname of tabs){
        const active=state.tab===tname;
        CTX.fillStyle=active?'#1a222b':'#0f141a'; roundRect(tx,sideY,tw,tabH,10*DPR,true,false);
        CTX.fillStyle=active?'#e2ebf5':'#9fb0c6'; CTX.font=`700 ${tabFs}px Inter`; CTX.textAlign='center'; CTX.textBaseline='middle'; CTX.fillText(tname,tx+tw/2,sideY+tabH/2);
        addClick(tx,sideY,tw,tabH,()=>{state.tab=tname; state.ui.scrollVel=0;});
        tx+=tw;
      }

      const listX=sideX+10*DPR, listY=sideY+tabH+10*DPR, listW=sidebarW-20*DPR, listH=sideH-tabH-20*DPR;
      CTX.save(); CTX.beginPath(); CTX.rect(listX,listY,listW,listH); CTX.clip();
      state.ui.sideRect={x:listX,y:listY,w:listW,h:listH};
      let sOff=state.scroll[state.tab]||0; let y=listY - sOff;

      if(state.tab==='Forge'){
        const rowH=70*DPR; CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,10*DPR,true,false);
        CTX.fillStyle='#9fb0c6'; CTX.font=`600 ${12*DPR}px Inter`; CTX.textAlign='left'; CTX.textBaseline='top';
        CTX.fillText(`Combo: ${(state.combo.v*100).toFixed(0)}% (decay ${Math.round(state.combo.decay*100)}%/s)`,listX+12*DPR,y+12*DPR);
        CTX.fillText(`PPS (after combo): ${fmt(totalPPS())} | RP/s: ${fmt(rpPerSec())}`,listX+12*DPR,y+32*DPR);
        y+=rowH+10*DPR;
        const rowH2=80*DPR; CTX.fillStyle='#0f141a'; roundRect(listX,y,listW,rowH2,10*DPR,true,false);
        CTX.fillStyle='#b6c6da'; CTX.font=`600 ${12*DPR}px Inter`;
        CTX.fillText('Hold inside the core to charge. Release in the highlighted arc for critical payout. Play Arcade for bursts & RP.',listX+12*DPR,y+14*DPR);
        y+=rowH2+10*DPR;
      }

      if(state.tab==='Shop'){
        const us=state.ui.scale||1, isNarrow=listW<460*DPR*us, baseRowH=(isNarrow?92:70)*DPR*us;
        for(const m of MODULES){
          const n=count(m.id), qty=BUY_QTY[state.buyQtyIndex], nToBuy=qty==='Max'?maxAffordable(m.id):qty;
          const cost=moduleCost(m.id,nToBuy), afford=nToBuy>0&&state.bits>=cost, rowH=baseRowH;
          CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,10*DPR*us,true,false);
          const nameX=listX+12*DPR*us, nameY=y+10*DPR*us;
          CTX.fillStyle='#e6eef6'; CTX.font=`800 ${15*DPR*us}px Inter`; CTX.textAlign='left'; CTX.textBaseline='top'; CTX.fillText(m.name,nameX,nameY);
          const label=qty==='Max'?`Buy ${nToBuy}`:`Buy x${nToBuy}`;
          const fsBtn=14*DPR*us; CTX.font=`700 ${fsBtn}px Inter`;
          const bw=Math.max(100*DPR*us,CTX.measureText(label).width+28*DPR*us), bh=32*DPR*us;
          const bx=listX+listW-bw-12*DPR*us, by=y+rowH-bh-10*DPR*us;

          if(isNarrow){
            CTX.fillStyle=afford?'#b8f0c2':'#93a6bf'; CTX.font=`800 ${13*DPR*us}px Inter`; CTX.textAlign='left';
            CTX.fillText(`Cost: ${fmt(cost)}`,nameX,nameY+20*DPR*us);
            CTX.fillStyle='#9fb0c6'; CTX.font=`600 ${12*DPR*us}px Inter`;
            CTX.fillText(`Owned: ${n} • +${fmt(moduleProd(m.id))}/s${m.rp?` • RP: ${m.rp}/s`:''}`,nameX,nameY+38*DPR*us);
          }else{
            CTX.fillStyle='#9fb0c6'; CTX.font=`600 ${12*DPR*us}px Inter`; CTX.textAlign='left';
            CTX.fillText(`Owned: ${n} • +${fmt(moduleProd(m.id))}/s${m.rp?` • RP: ${m.rp}/s`:''}`,nameX,nameY+22*DPR*us);
            CTX.fillStyle=afford?'#b8f0c2':'#93a6bf'; CTX.font=`800 ${14*DPR*us}px Inter`; CTX.textAlign='right';
            CTX.fillText(`Cost: ${fmt(cost)}`,bx-12*DPR*us,nameY+2*DPR*us);
          }

          drawButton(bx,by,bw,bh,label,afford,true); addClick(bx,by,bw,bh,()=>buyModule(m.id));
          y+=rowH+10*DPR*us;
        }
      }

      if(state.tab==='Research'){
        // Open Fullscreen button
        const btnW=180*DPR, btnH=34*DPR;
        drawButton(listX,y,btnW,btnH,'Open Full Tree',true,true);
        addClick(listX,y,btnW,btnH,()=>{ state.ui.researchOverlay.open=true; state.ui.researchOverlay.camX=0; state.ui.researchOverlay.camY=0; });
        y+=btnH+10*DPR;

        const cxTree=listX+listW/2, unit=120*DPR;
        const maxDepth=TECH.reduce((m,t)=>Math.max(m,t.pos[1]),0);
        for(const t of TECH){ for(const p of t.pre){ const tp=TECH.find(x=>x.id===p); const x1=cxTree+(tp.pos[0]*unit), y1=y+30*DPR+tp.pos[1]*unit; const x2=cxTree+(t.pos[0]*unit), y2=y+30*DPR+t.pos[1]*unit; CTX.strokeStyle='#24303c'; CTX.lineWidth=2*DPR; CTX.beginPath(); CTX.moveTo(x1,y1); CTX.lineTo(x2,y2); CTX.stroke(); } }
        for(const t of TECH){
          const nx=cxTree+(t.pos[0]*unit), ny=y+30*DPR+t.pos[1]*unit; const owned=hasTech(t.id); const avail=techAvailable(t)&&state.rp>=t.rp;
          CTX.fillStyle=owned?'#1f3427':(avail?'#1f2631':'#11161d'); CTX.beginPath(); CTX.arc(nx,ny,22*DPR,0,Math.PI*2); CTX.fill();
          CTX.strokeStyle=avail?'#7fd1ff':'#2a3949'; CTX.lineWidth=2*DPR; CTX.stroke();
          CTX.fillStyle=owned?'#c8f7da':'#e6eef6'; CTX.font=`700 ${12*DPR}px Inter`; CTX.textAlign='center'; CTX.textBaseline='middle'; CTX.fillText(t.name,nx,ny-34*DPR);
          CTX.fillStyle='#9fb0c6'; CTX.font=`600 ${11*DPR}px Inter`; CTX.fillText(`${t.desc} • ${t.rp} RP`,nx,ny+34*DPR);
          addClick(nx-24*DPR,ny-24*DPR,48*DPR,48*DPR,()=>buyTech(t));
        }
        y+=30*DPR+(maxDepth+1)*unit+40*DPR;
      }

      if(state.tab==='Arcade'){
        const us=state.ui.scale||1, isNarrow=listW<500*DPR*us;
        function row(title,desc,onClick){
          const fs=14*DPR*us; CTX.font=`700 ${fs}px Inter`; const btnTextW=CTX.measureText(title).width;
          const bw=Math.max(160*DPR*us,Math.min(260*DPR*us,btnTextW+28*DPR*us)), bh=36*DPR*us;
          const rowH=isNarrow?(bh+32*DPR*us+22*DPR*us):56*DPR*us;
          CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,10*DPR*us,true,false);
          const bx=listX+12*DPR*us, by=y+10*DPR*us; drawButton(bx,by,bw,bh,title,true,true); addClick(bx,by,bw,bh,onClick);
          CTX.fillStyle='#9fb0c6'; CTX.font=`600 ${12*DPR*us}px Inter`; CTX.textAlign='left';
          if(isNarrow) CTX.fillText(desc,bx,by+bh+16*DPR*us); else {const dx=bx+bw+14*DPR*us, dy=y+rowH/2+4*DPR*us; CTX.textBaseline='middle'; CTX.fillText(desc,dx,dy);}
          y+=rowH+10*DPR*us;
        }
        row('Start Pulse Rush','Rapid orbs spawn. Click them for Bits and RP.',()=>startPulseRush());
        row('Start Timing Gate','Stop the marker in the zone with Space/click.',()=>startGate());
        row('Start Meteor Dodge+','Dodge meteors, comets, shards, and lasers.',()=>startMeteor());
      }

      if(state.tab==='Achievements'){
        const rows=[['First Pulse','Release a charged pulse once',state.lifetimeBits>0],['Collector','Own 20 modules total',state.modules.reduce((a,b)=>a+(b.count||0),0)>=20],['Researcher','Spend 50 RP',state.rpTotal>=50],['Arcader','Finish a minigame',state.arcadeLastRewarded]];
        for(const r of rows){const rowH=48*DPR; CTX.fillStyle=r[2]?'#14211a':'#121821'; roundRect(listX,y,listW,rowH,10*DPR,true,false); CTX.fillStyle=r[2]?'#e2f6e9':'#e8f0f8'; CTX.font=`800 ${14*DPR}px Inter`; CTX.textAlign='left'; CTX.textBaseline='middle'; CTX.fillText(r[0],listX+12*DPR,y+rowH/2-10*DPR); CTX.fillStyle='#9fb0c6'; CTX.font=`600 ${12*DPR}px Inter`; CTX.fillText(r[1],listX+12*DPR,y+rowH/2+10*DPR); y+=rowH+8*DPR;}
      }

      if(state.tab==='Stats'){
        const stats=[['Bits',fmt(state.bits)],['Lifetime Bits',fmt(state.lifetimeBits)],['PPS (base)',fmt(totalPPS()/(1+state.combo.v))],['PPS (with combo)',fmt(totalPPS())],['RP',fmt(state.rp)],['RP/s',fmt(rpPerSec())],['Modules',state.modules.reduce((a,b)=>a+(b.count||0),0).toString()],['Cores',fmt(state.ascend.cores)]];
        for(const [k,v] of stats){const rowH=40*DPR; CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,8*DPR,true,false); CTX.fillStyle='#a9b9cf'; CTX.font=`600 ${12*DPR}px Inter`; CTX.textAlign='left'; CTX.textBaseline='middle'; CTX.fillText(k,listX+12*DPR,y+rowH/2); CTX.textAlign='right'; CTX.fillStyle='#e8f0f8'; CTX.font=`800 ${13*DPR}px Inter`; CTX.fillText(v,listX+listW-12*DPR,y+rowH/2); y+=rowH+8*DPR;}
      }

      if(state.tab==='Ascend'){
        const gain=coreGain(); const rowH=120*DPR; CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,10*DPR,true,false);
        CTX.fillStyle='#e8f0f8'; CTX.font=`800 ${16*DPR}px Inter`; CTX.textAlign='left'; CTX.textBaseline='top'; CTX.fillText('Ascend resets progress for permanent Cores',listX+12*DPR,y+10*DPR);
        CTX.fillStyle='#9fb0c6'; CTX.font=`600 ${13*DPR}px Inter`; CTX.fillText(`You would gain: ${gain} cores (global x${(1+(state.ascend.cores+gain)*0.1).toFixed(2)})`,listX+12*DPR,y+32*DPR);
        const bw=160*DPR,bh=36*DPR; const bx=listX+listW-bw-12*DPR, by=y+rowH-bh-12*DPR; drawButton(bx,by,bw,bh,'Ascend (P)',gain>0,true); addClick(bx,by,bw,bh,()=>tryAscend());
      }

      if(state.tab==='Settings'){
        const items=[['Particles','particles'],['Low FX','lowFX'],['Mute (M)','mute'],['Export (E)','export'],['Import (I)','import']];
        for(const it of items){
          const rowH=44*DPR; CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,8*DPR,true,false);
          CTX.fillStyle='#e8f0f8'; CTX.font=`700 ${13*DPR}px Inter`; CTX.textAlign='left'; CTX.textBaseline='middle'; CTX.fillText(it[0],listX+12*DPR,y+rowH/2);
          const bw=110*DPR,bh=30*DPR; const bx=listX+listW-bw-12*DPR, by=y+rowH/2-bh/2;
          if(it[1]==='export'){drawButton(bx,by,bw,bh,'Export',true,true);addClick(bx,by,bw,bh,()=>doExport());}
          else if(it[1]==='import'){drawButton(bx,by,bw,bh,'Import',true,true);addClick(bx,by,bw,bh,()=>doImport());}
          else{const key=it[1]; const val=state.settings[key]; drawButton(bx,by,bw,bh,val?'ON':'OFF',true,val); addClick(bx,by,bw,bh,()=>{state.settings[key]=!state.settings[key];});}
          y+=rowH+8*DPR;
        }
        const rowH=60*DPR; CTX.fillStyle='#121821'; roundRect(listX,y,listW,rowH,8*DPR,true,false);
        CTX.fillStyle='#e8f0f8'; CTX.font=`700 ${13*DPR}px Inter`; CTX.textAlign='left'; CTX.textBaseline='top'; CTX.fillText('Buy Quantity ([-] / [=])',listX+12*DPR,y+10*DPR);
        const wBtn=70*DPR; let bx=listX+12*DPR; const by=y+rowH-38*DPR;
        BUY_QTY.forEach((q,i)=>{const on=i===state.buyQtyIndex; drawButton(bx,by,wBtn,28*DPR,q.toString(),true,on); addClick(bx,by,wBtn,28*DPR,()=>{state.buyQtyIndex=i;}); bx+=wBtn+8*DPR;});
      }

      CTX.restore();

      // ===== SCROLL FIX (measures with offset undone) =====
      state.ui.maxScroll = Math.max(0, (y + sOff) - (listY + listH));
      sOff = clamp(sOff, 0, state.ui.maxScroll);
      state.scroll[state.tab] = sOff;

      // Wheel & inertia
      if(!(state.ui.researchOverlay && state.ui.researchOverlay.open) && Math.abs(input.wheel)>0.1){ state.ui.scrollVel += input.wheel*0.6; input.wheel=0; } else if(state.ui.researchOverlay && state.ui.researchOverlay.open){ input.wheel=0; }
      if(!state.ui.scrollDrag.active){
        if(Math.abs(state.ui.scrollVel)>0.1){
          sOff = clamp(sOff + state.ui.scrollVel, 0, state.ui.maxScroll);
          state.ui.scrollVel *= 0.86;
          state.scroll[state.tab]=sOff;
        }
      } else {
        state.ui.scrollVel *= 0.6;
      }
    }

    drawParticles(); drawArcade(); drawResearchOverlay(); drawToasts();
  }

  function dispatchClick(px,py){
    if(state.rift.active&&tryClickRift(px,py)) return;
    for(let i=clicks.length-1;i>=0;i--){const c=clicks[i]; if(hit(px,py,c)){c.onClick(px,py); return;}}
    if(state.arcade.active){/* handleArcadeClick consumed via clicks in modes */ return;}
    if(tryClickGlitch(px,py)) return;
  }

  function doExport(){try{const data=localStorage.getItem(SAVE_KEY)||JSON.stringify({...state,mults,mods}); if(navigator.clipboard&&location.protocol!=='file:'){navigator.clipboard.writeText(data).then(()=>toast('Save copied')).catch(()=>alert(data));}else alert(data);}catch{alert('Export failed');}}
  function doImport(){const data=prompt('Paste your save data:'); if(!data)return; try{localStorage.setItem(SAVE_KEY,data);toast('Imported. Reloading…');setTimeout(()=>location.reload(),400);}catch{toast('Import failed');}}

  let saveAcc=0; function autoSave(dt){saveAcc+=dt;if(saveAcc>10){saveAcc=0;save();}}

  let last=nowMs(); function loop(){resize();const t=nowMs();let dt=(t-last)/1000;last=t;dt=clamp(dt,0,0.1);if(state.settings.lowFX)dt*=0.9;update(dt);draw(dt);autoSave(dt);prevDown=input.down;requestAnimationFrame(loop);} loop();
})();
</script>
</body>
</html>
