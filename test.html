<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Camera AR Hypercube</title>
<style>
  html, body { margin:0; height:100%; background:#000; overflow:hidden; }
  #wrap { position:fixed; inset:0; }
  #videoBG { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; transform:scaleX(-1); /* mirror for selfie; removed if rear camera */ }
  #three { position:absolute; inset:0; }
  #ui { position: fixed; left: 0; right: 0; bottom: 0; padding: 10px 12px;
        display: flex; gap: 10px; justify-content: space-between; align-items: center;
        background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,.4) 40%, rgba(0,0,0,.8) 100%);
        color: #fff; font: 15px/1.2 system-ui, -apple-system, Roboto, Segoe UI, Arial, sans-serif; }
  button { appearance:none; border:0; padding:10px 12px; border-radius:12px; font-weight:700; }
  #start { background:#00d084; color:#001a12; }
  #flip { background:#222; color:#fff; }
  #hint { opacity:.95 }
</style>
</head>
<body>
<div id="wrap">
  <video id="videoBG" autoplay playsinline muted></video>
  <canvas id="three"></canvas>
</div>

<div id="ui">
  <div id="hint">Tap <b>Start Camera</b>. Drag to rotate. Pinch to scale.</div>
  <div>
    <button id="start">Start Camera</button>
    <button id="flip" disabled>Flip</button>
  </div>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.159/build/three.module.js';

const video = document.getElementById('videoBG');
const canvas = document.getElementById('three');
const startBtn = document.getElementById('start');
const flipBtn = document.getElementById('flip');
const hint = document.getElementById('hint');

let usingEnvironment = true;
let currentStream = null;

// Start camera with facingMode preference
async function startCamera() {
  try {
    if (currentStream) currentStream.getTracks().forEach(t => t.stop());
    const constraints = {
      video: {
        facingMode: usingEnvironment ? { ideal: 'environment' } : { ideal: 'user' },
        width: { ideal: 1920 },
        height: { ideal: 1080 }
      },
      audio: false
    };
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    currentStream = stream;
    video.srcObject = stream;
    startBtn.textContent = 'Camera On';
    startBtn.disabled = true;
    flipBtn.disabled = false;
    // If rear camera, do NOT mirror
    video.style.transform = usingEnvironment ? 'none' : 'scaleX(-1)';
    hint.textContent = 'Drag to rotate. Pinch to scale. Double-tap to reset.';
  } catch (e) {
    console.warn(e);
    hint.textContent = 'Camera blocked or unavailable. You can still view the cube.';
    startBtn.textContent = 'Retry Camera';
    startBtn.disabled = false;
  }
}

flipBtn.addEventListener('click', () => {
  usingEnvironment = !usingEnvironment;
  startBtn.disabled = false;
  startBtn.textContent = 'Start Camera';
  startCamera();
});

startBtn.addEventListener('click', startCamera);

// THREE setup
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
resize();
addEventListener('resize', resize);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 100);
camera.position.set(0, 0, 2);

// Soft light for visibility
scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 1.0));

// Create tesseract
const group = new THREE.Group();
scene.add(group);

// 4D vertices
const verts4 = [];
for (let x of [-1, 1]) for (let y of [-1, 1]) for (let z of [-1, 1]) for (let w of [-1, 1]) {
  verts4.push([x, y, z, w]);
}

// edges between vertices that differ by 1 coordinate
const edges = [];
for (let i=0; i<verts4.length; i++) for (let j=i+1; j<verts4.length; j++) {
  let d=0; for (let k=0;k<4;k++) if (verts4[i][k]!==verts4[j][k]) d++;
  if (d===1) edges.push([i,j]);
}

// geometry
const pos = new Float32Array(edges.length*2*3);
const geo = new THREE.BufferGeometry();
geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
const mat = new THREE.LineBasicMaterial({ transparent:true, opacity:0.95 });
const lines = new THREE.LineSegments(geo, mat);
group.add(lines);

const ptsGeo = new THREE.BufferGeometry();
ptsGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(verts4.length*3), 3));
const ptsMat = new THREE.PointsMaterial({ size: 0.02, transparent:true, opacity:0.95 });
const points = new THREE.Points(ptsGeo, ptsMat);
group.add(points);

// colors shift
const colorA = new THREE.Color(0x66ccff);
const colorB = new THREE.Color(0xff66cc);

// 4D angles
let axw=0, ayw=0.7, azw=1.1;
let scale = 0.6;

// gestures: rotate + pinch scale
let isPointerDown = false, lastX=0, lastY=0;
let rotY=0, rotX=0;
let lastDist = 0;
let lastTapTime = 0;

function getDist(touches) {
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.hypot(dx, dy);
}

canvas.addEventListener('pointerdown', e => {
  isPointerDown = true; lastX=e.clientX; lastY=e.clientY;
});
addEventListener('pointerup', () => isPointerDown = false);
addEventListener('pointermove', e => {
  if (!isPointerDown) return;
  const dx = e.clientX - lastX;
  const dy = e.clientY - lastY;
  rotY += dx * 0.005;
  rotX += dy * 0.005;
  lastX = e.clientX; lastY = e.clientY;
});

canvas.addEventListener('touchstart', e => {
  if (e.touches.length===2) {
    lastDist = getDist(e.touches);
  } else if (e.touches.length===1) {
    const now = performance.now();
    if (now - lastTapTime < 300) {
      // double-tap reset
      rotX = rotY = 0; scale = 0.6;
    }
    lastTapTime = now;
  }
}, {passive:true});

canvas.addEventListener('touchmove', e => {
  if (e.touches.length===2) {
    const d = getDist(e.touches);
    const delta = d - lastDist;
    scale = Math.min(2.0, Math.max(0.2, scale + delta * 0.002));
    lastDist = d;
  }
}, {passive:true});

function rotate4D([x,y,z,w]){
  const cx=Math.cos(axw), sx=Math.sin(axw);
  const cy=Math.cos(ayw), sy=Math.sin(ayw);
  const cz=Math.cos(azw), sz=Math.sin(azw);
  // XW
  let x1 = x*cx - w*sx, w1 = x*sx + w*cx;
  let y1=y, z1=z;
  // YW
  let y2 = y1*cy - w1*sy, w2 = y1*sy + w1*cy;
  let x2=x1, z2=z1;
  // ZW
  let z3 = z2*cz - w2*sz, w3 = z2*sz + w2*cz;
  let x3=x2, y3=y2;
  return [x3,y3,z3,w3];
}

function project([x,y,z,w]){
  const d = 2.2;
  const k = 1.0/(d - w);
  return [x*k, y*k, z*k];
}

function updateGeometry(){
  const t = (performance.now()*0.0003)%1.0;
  const c = colorA.clone().lerp(colorB, 0.5 + 0.5*Math.sin(t*2*Math.PI));
  mat.color.copy(c);
  ptsMat.color.copy(c);

  // points
  const pArr = points.geometry.attributes.position.array;
  for (let i=0;i<verts4.length;i++){
    const v = rotate4D(verts4[i]);
    const [px,py,pz] = project(v);
    pArr[i*3+0] = px*scale;
    pArr[i*3+1] = py*scale;
    pArr[i*3+2] = pz*scale;
  }
  points.geometry.attributes.position.needsUpdate = true;

  // lines
  const lArr = lines.geometry.attributes.position.array;
  for (let e=0;e<edges.length;e++){
    const [i,j] = edges[e];
    const vi = project(rotate4D(verts4[i]));
    const vj = project(rotate4D(verts4[j]));
    lArr[e*6+0]=vi[0]*scale; lArr[e*6+1]=vi[1]*scale; lArr[e*6+2]=vi[2]*scale;
    lArr[e*6+3]=vj[0]*scale; lArr[e*6+4]=vj[1]*scale; lArr[e*6+5]=vj[2]*scale;
  }
  lines.geometry.attributes.position.needsUpdate = true;
}

function resize(){
  const w = innerWidth, h = innerHeight;
  renderer.setSize(w, h, false);
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
}

renderer.setAnimationLoop(()=>{
  // 4D spin
  axw += 0.015; ayw += 0.010; azw += 0.012;

  // 3D orientation
  group.rotation.y = rotY;
  group.rotation.x = rotX;

  updateGeometry();
  renderer.render(scene, camera);
});

// Autostart camera if permissions were previously granted
if (navigator.permissions && navigator.permissions.query) {
  try {
    navigator.permissions.query({ name: 'camera' }).then(p => {
      if (p.state === 'granted') startCamera();
    }).catch(()=>{});
  } catch {}
}
</script>
</body>
</html>

