<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<title>Vision HW Helper — Mobile (v6 Chat + Homework)</title>
<style>
  :root{--bg:#0b0b10;--panel:#10141b;--ink:#eef2f6;--muted:#a6b0c2;--acc:#4da3ff;--bad:#ff5d6c;--ok:#74ffa4}
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html,body{height:100%}
  body{margin:0;background:linear-gradient(180deg,#0b0b10,#0d1117);color:var(--ink);
       font:16px/1.45 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto}
  header{position:sticky;top:0;z-index:4;background:#0c1016;border-bottom:1px solid #1d2431;padding:12px 14px}
  h1{margin:0;font-size:18px}
  .wrap{max-width:820px;margin:0 auto;padding:12px}
  .card{background:var(--panel);border:1px solid #1d2431;border-radius:16px;overflow:hidden;box-shadow:0 8px 28px rgba(0,0,0,.35);margin-bottom:12px}
  .pad{padding:14px}
  label{display:block;margin:0 0 6px 2px;color:var(--muted);font-size:13px}
  input,select,textarea,button{font-size:16px}
  input[type="password"],input[type="text"],select,textarea{width:100%;padding:10px 12px;border-radius:12px;border:1px solid #273246;background:#0d1117;color:var(--ink)}
  textarea{min-height:90px}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .row>*{flex:1 1 240px}
  .tabs{display:flex;gap:6px;border-bottom:1px solid #1d2431}
  .tab{padding:10px 12px;cursor:pointer;border-radius:10px 10px 0 0;background:#0e1420;color:#bcd}
  .tab.active{background:#151c29;color:#fff;border:1px solid #1f2839;border-bottom:0}
  .section{display:none}
  .section.active{display:block}
  .switch{display:flex;align-items:center;gap:8px}
  .small{font-size:13px;color:var(--muted)}
  .drop{border:1.5px dashed #2a3647;border-radius:14px;padding:12px;text-align:center;color:#b6c0d2;background:#0d1219}
  .thumbs{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
  .thumb{position:relative}
  .thumb img{height:84px;border-radius:10px;border:1px solid #263145;display:block}
  .del{position:absolute;top:-8px;right:-8px;background:#ff5d6c;border:0;color:#0b0b10;width:28px;height:28px;border-radius:16px;font-weight:800;cursor:pointer}
  .actions{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;border:0;border-radius:12px;background:var(--acc);color:#08101b;font-weight:800}
  .btn.secondary{background:#182235;color:#c8d3e6;border:1px solid #263145}
  .btn.warn{background:#ff5d6c;color:#1b0b0b}
  .btn:disabled{opacity:.6}
  .out{white-space:pre-wrap;background:#0a0e14;border-top:1px solid #1e2430;padding:14px;max-height:55vh;overflow:auto}
  /* Chat UI */
  .chat{display:flex;flex-direction:column;gap:10px;max-height:60vh;overflow:auto;padding:10px;background:#0b1119;border:1px solid #1d2431;border-radius:12px}
  .bubble{max-width:85%;padding:10px 12px;border-radius:14px;line-height:1.4;word-wrap:break-word;white-space:pre-wrap}
  .me{align-self:flex-end;background:#182235;border:1px solid #263145}
  .bot{align-self:flex-start;background:#0f1522;border:1px solid #243046}
  .sys{align-self:center;background:#0c1320;border:1px dashed #2a3a55;color:#9db4d8}
  .bubble img{max-width:100%;border-radius:10px;margin-top:6px;border:1px solid #263145}
  .composer{display:flex;flex-direction:column;gap:8px}
  .inline{display:flex;gap:8px}
  .inline input[type="text"]{flex:1}
  .hint{display:inline-block;background:#101b2a;border:1px solid #22314a;border-radius:999px;padding:4px 10px;color:#b9c9e2;font-size:12px;margin-right:6px;margin-top:6px}
  .ok{color:var(--ok)}
  .warnTxt{color:var(--bad)}
</style>
</head>
<body>
<header><h1>Vision HW Helper — Mobile (v6)</h1></header>
<div class="wrap">

  <!-- Provider & Keys -->
  <div class="card"><div class="pad">
    <div class="row">
      <div>
        <label for="provider">Provider</label>
        <select id="provider">
          <option value="openai" selected>OpenAI</option>
          <option value="google">Google (Gemini)</option>
          <option value="anthropic">Anthropic (Claude)</option>
        </select>
      </div>
      <div>
        <label for="model">Model</label>
        <select id="model"></select>
      </div>
    </div>

    <div class="row" style="margin-top:6px">
      <div>
        <label for="apiKey">API Key</label>
        <input id="apiKey" type="password" placeholder="sk-... / AIza... / sk-ant-..." autocomplete="off"/>
        <div class="switch" style="margin-top:8px">
          <input id="remember" type="checkbox"/>
          <label for="remember" class="small">Remember key on this device (localStorage)</label>
        </div>
      </div>
      <div id="baseUrlBox" style="display:none">
        <label for="baseUrl">Base URL (optional)</label>
        <input id="baseUrl" type="text" placeholder="Only for OpenAI-compatible proxies"/>
      </div>
    </div>

    <div class="row" style="margin-top:6px">
      <div class="switch">
        <input id="reasoningToggle" type="checkbox"/>
        <label for="reasoningToggle" class="small">Enable reasoning effort (o3/o4, GPT-5 Thinking/Pro)</label>
      </div>
      <div>
        <label for="effort" class="small">Reasoning effort</label>
        <select id="effort">
          <option value="low">low</option>
          <option value="medium" selected>medium</option>
          <option value="high">high</option>
        </select>
      </div>
    </div>
    <div class="small" id="capNote" style="margin-top:6px"></div>
  </div></div>

  <!-- Tabs -->
  <div class="card">
    <div class="tabs">
      <div class="tab active" data-tab="chat">Chat Mode</div>
      <div class="tab" data-tab="homework">Homework Mode</div>
    </div>

    <!-- Chat Mode -->
    <div id="chat" class="section active">
      <div class="pad">
        <div id="chatlog" class="chat"></div>

        <!-- Attachments for NEXT user message only -->
        <div class="pad" style="padding-left:0;padding-right:0">
          <label>Attach images (optional)</label>
          <div id="chatDrop" class="drop">
            <div>Tap to add photos or use camera</div>
            <input id="chatFile" type="file" accept="image/*" capture="environment" multiple style="display:none"/>
            <div class="actions" style="justify-content:center;margin-top:6px">
              <button class="btn secondary" id="chatPick">Choose Photos</button>
              <button class="btn secondary" id="chatCam">Open Camera</button>
              <button class="btn secondary" id="chatPaste">Paste Clipboard</button>
              <button class="btn secondary" id="chatClearImgs">Clear All</button>
            </div>
            <div id="chatThumbs" class="thumbs"></div>
          </div>
        </div>

        <div class="composer">
          <div class="inline">
            <input id="chatInput" type="text" placeholder="Ask anything…"/>
            <button class="btn" id="sendChat">Send</button>
          </div>
          <div class="actions">
            <button class="btn secondary" id="clearChat">Clear Chat</button>
            <span class="small">Tip: images here attach to your <b>next</b> message only.</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Homework Mode -->
    <div id="homework" class="section">
      <div class="pad">
        <div class="row">
          <div>
            <label for="hwPrompt">Task</label>
            <textarea id="hwPrompt" placeholder="Explain each step and show your reasoning."></textarea>
            <div class="small" style="margin-top:6px">
              Quick templates:
              <span class="hint" data-t="Explain step by step.">Explain step by step.</span>
              <span class="hint" data-t="Check my work. Show where I made mistakes.">Check my work.</span>
              <span class="hint" data-t="Give the next hint only, don't give the final answer yet.">Next hint only.</span>
            </div>
          </div>
        </div>

        <div style="margin-top:10px">
          <label>Take/Upload Homework Photo(s)</label>
          <div id="hwDrop" class="drop">
            <div>Tap to add photos or use camera</div>
            <input id="hwFile" type="file" accept="image/*" capture="environment" multiple style="display:none"/>
            <div class="actions" style="justify-content:center;margin-top:6px">
              <button class="btn secondary" id="hwPick">Choose Photos</button>
              <button class="btn secondary" id="hwCam">Open Camera</button>
              <button class="btn secondary" id="hwPaste">Paste Clipboard</button>
              <button class="btn secondary" id="hwClearImgs">Clear All</button>
            </div>
            <div id="hwThumbs" class="thumbs"></div>
          </div>
        </div>

        <div class="actions" style="margin-top:12px">
          <button class="btn" id="askHw">Get Feedback</button>
          <button class="btn secondary" id="nextHint">Ask for Next Hint</button>
        </div>

        <div id="hwOut" class="out" style="margin-top:10px"></div>
      </div>
    </div>
  </div>

  <div class="card"><div class="pad small">
    ⚠️ Learn with it; don’t submit raw AI answers if that breaks your rules. Keys stay on device unless you toggle “Remember.”
  </div></div>

</div>

<script>
  const el = id => document.getElementById(id);

  /* ---------- Provider / Models / Caps ---------- */
  const provider = el('provider'), model = el('model'), apiKey = el('apiKey'),
        baseUrl = el('baseUrl'), baseUrlBox = el('baseUrlBox'),
        reasoningToggle = el('reasoningToggle'), effort = el('effort'), capNote = el('capNote'),
        remember = el('remember');

  const MODELS = {
    openai: {
      list: [
        {id:'gpt-4o', label:'gpt-4o (vision)', reason:false},
        {id:'gpt-4o-mini', label:'gpt-4o-mini (vision, cheap)', reason:false},
        {id:'gpt-4.1-mini', label:'gpt-4.1-mini (vision)', reason:false},
        {id:'o3-mini', label:'o3-mini (reasoning + vision)', reason:true},
        {id:'o4-mini', label:'o4-mini (reasoning + vision)', reason:true},
        /* GPT-5 additions (may require access) */
        {id:'gpt-5', label:'gpt-5 (vision)', reason:false},
        {id:'gpt-5-thinking', label:'gpt-5-thinking (reasoning + vision)', reason:true},
        {id:'gpt-5pro', label:'gpt-5pro (reasoning + vision)', reason:true}
      ],
      reasonNote: 'Reasoning available on o3/o4 and GPT-5 Thinking/Pro. If your key lacks access, the API may return 404/400.'
    },
    google: {
      list: [
        {id:'gemini-1.5-flash', label:'gemini-1.5-flash (vision)', reason:false},
        {id:'gemini-1.5-flash-8b', label:'gemini-1.5-flash-8b (vision, light)', reason:false},
        {id:'gemini-1.5-pro', label:'gemini-1.5-pro (vision)', reason:false}
      ],
      reasonNote: 'Gemini doesn’t use OpenAI’s reasoning parameter.'
    },
    anthropic: {
      list: [
        {id:'claude-3-5-sonnet-20241022', label:'claude-3.5-sonnet (vision)', reason:false},
        {id:'claude-3-5-haiku-20241022', label:'claude-3.5-haiku (vision, light)', reason:false}
      ],
      reasonNote: 'Claude has its own API; no OpenAI reasoning parameter.'
    }
  };

  function populateModels(){
    model.innerHTML = '';
    const m = MODELS[provider.value];
    for (const it of m.list){
      const o = document.createElement('option');
      o.value = it.id; o.textContent = it.label; model.appendChild(o);
    }
    refreshCaps();
    baseUrlBox.style.display = provider.value === 'openai' ? 'block' : 'none';
    // Load saved key for this provider
    try{
      const saved = localStorage.getItem('vh_key_'+provider.value);
      apiKey.value = saved || ''; remember.checked = !!saved;
    }catch{}
  }

  function refreshCaps(){
    const m = MODELS[provider.value];
    const current = m.list.find(x=>x.id===model.value) || m.list[0];
    const canReason = provider.value === 'openai' && current.reason;
    reasoningToggle.disabled = !canReason;
    effort.disabled = !canReason;
    if (!canReason) reasoningToggle.checked = false;
    capNote.textContent = canReason ? 'Reasoning supported on this model.' : (m.reasonNote || '');
  }

  provider.addEventListener('change', populateModels);
  model.addEventListener('change', refreshCaps);
  populateModels();

  // Persist key per provider
  remember.addEventListener('change', ()=>{
    try{
      if (remember.checked) localStorage.setItem('vh_key_'+provider.value, apiKey.value.trim());
      else localStorage.removeItem('vh_key_'+provider.value);
    }catch{}
  });
  apiKey.addEventListener('input', ()=>{
    if (remember.checked){
      try{ localStorage.setItem('vh_key_'+provider.value, apiKey.value.trim()); }catch{}
    }
  });

  /* ---------- Tabs ---------- */
  document.querySelectorAll('.tab').forEach(t=>{
    t.addEventListener('click', ()=>{
      document.querySelectorAll('.tab').forEach(a=>a.classList.remove('active'));
      document.querySelectorAll('.section').forEach(s=>s.classList.remove('active'));
      t.classList.add('active');
      el(t.dataset.tab).classList.add('active');
    });
  });

  /* ---------- Image helpers ---------- */
  async function filesToDataURLs(list){
    const arr=[];
    for (const f of list){
      const url = await new Promise((res,rej)=>{
        const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(f);
      });
      arr.push(url);
    }
    return arr;
  }
  async function clipboardToDataURLs(){
    const out=[];
    const items = await navigator.clipboard.read();
    for (const it of items){
      for (const type of it.types){
        if (type.startsWith('image/')){
          const blob = await it.getType(type);
          const url = await new Promise((res)=>{
            const r=new FileReader(); r.onload=()=>res(r.result); r.readAsDataURL(blob);
          });
          out.push(url);
        }
      }
    }
    return out;
  }

  /* ---------- Chat Mode State & UI ---------- */
  const chatlog = el('chatlog');
  const chatInput = el('chatInput');
  const sendChat = el('sendChat');
  const clearChat = el('clearChat');
  const chatDrop = el('chatDrop'), chatFile = el('chatFile'), chatPick = el('chatPick'),
        chatCam = el('chatCam'), chatPaste = el('chatPaste'), chatClearImgs = el('chatClearImgs'),
        chatThumbs = el('chatThumbs');

  // nextUserImages: images attached to the NEXT user message only
  let nextUserImages = [];

  function renderNextUserThumbs(){
    chatThumbs.innerHTML='';
    nextUserImages.forEach((src, idx)=>{
      const wrap = document.createElement('div'); wrap.className='thumb';
      const img = new Image(); img.src=src; img.loading='lazy';
      const btn = document.createElement('button'); btn.className='del'; btn.textContent='×';
      btn.addEventListener('click', ()=>{ nextUserImages.splice(idx,1); renderNextUserThumbs(); });
      wrap.appendChild(img); wrap.appendChild(btn); chatThumbs.appendChild(wrap);
    });
  }
  function addNextUserThumbs(urls){ nextUserImages.push(...urls); renderNextUserThumbs(); }

  chatPick.addEventListener('click', ()=>{ chatFile.removeAttribute('capture'); chatFile.click(); });
  chatCam.addEventListener('click', ()=>{ chatFile.setAttribute('capture','environment'); chatFile.click(); });
  chatFile.addEventListener('change', async e=>{
    const urls = await filesToDataURLs(e.target.files); addNextUserThumbs(urls); chatFile.value='';
  });
  chatPaste.addEventListener('click', async ()=>{
    try{ const urls = await clipboardToDataURLs(); addNextUserThumbs(urls); }
    catch{ alert('Clipboard read not supported here.'); }
  });
  chatDrop.addEventListener('dragover', (e)=>{ e.preventDefault(); chatDrop.classList.add('hover'); });
  chatDrop.addEventListener('dragleave', ()=> chatDrop.classList.remove('hover'));
  chatDrop.addEventListener('drop', async e=>{
    e.preventDefault(); chatDrop.classList.remove('hover');
    const urls = await filesToDataURLs(e.dataTransfer.files); addNextUserThumbs(urls);
  });
  chatClearImgs.addEventListener('click', ()=>{ nextUserImages=[]; renderNextUserThumbs(); });

  // Chat history we maintain locally
  // { role: 'user'|'assistant'|'system', text: string, images?: [dataURI,...] }
  const chatHistory = [
    { role: 'system', text: 'You are a helpful, concise assistant. Use images if provided. In Homework Mode, give hints before answers.' }
  ];

  function addBubble(role, text, imgs){
    const b = document.createElement('div');
    b.className = 'bubble ' + (role==='user'?'me':role==='assistant'?'bot':'sys');
    if (text) b.textContent = text;
    if (imgs && imgs.length){
      imgs.forEach(src=>{
        const im = new Image(); im.src=src; b.appendChild(im);
      });
    }
    chatlog.appendChild(b);
    chatlog.scrollTop = chatlog.scrollHeight;
  }
  // initial system bubble
  addBubble('system', 'Chat Mode ready. Attach images to your next message if needed.');

  clearChat.addEventListener('click', ()=>{
    chatHistory.length = 0;
    chatHistory.push({ role:'system', text:'You are a helpful, concise assistant. Use images if provided. In Homework Mode, give hints before answers.'});
    chatlog.innerHTML='';
    addBubble('system','Chat cleared.');
  });

  /* ---------- Homework Mode State ---------- */
  const hwPrompt = el('hwPrompt');
  const hwDrop = el('hwDrop'), hwFile = el('hwFile'), hwPick = el('hwPick'),
        hwCam = el('hwCam'), hwPaste = el('hwPaste'), hwClearImgs = el('hwClearImgs'),
        hwThumbs = el('hwThumbs'), hwOut = el('hwOut'), askHw = el('askHw'), nextHint = el('nextHint');

  let hwImages = [];
  function renderHwThumbs(){
    hwThumbs.innerHTML='';
    hwImages.forEach((src, idx)=>{
      const wrap = document.createElement('div'); wrap.className='thumb';
      const img = new Image(); img.src=src; img.loading='lazy';
      const btn = document.createElement('button'); btn.className='del'; btn.textContent='×';
      btn.addEventListener('click', ()=>{ hwImages.splice(idx,1); renderHwThumbs(); });
      wrap.appendChild(img); wrap.appendChild(btn); hwThumbs.appendChild(wrap);
    });
  }
  function addHwThumbs(urls){ hwImages.push(...urls); renderHwThumbs(); }

  hwPick.addEventListener('click', ()=>{ hwFile.removeAttribute('capture'); hwFile.click(); });
  hwCam.addEventListener('click', ()=>{ hwFile.setAttribute('capture','environment'); hwFile.click(); });
  hwFile.addEventListener('change', async e=>{
    const urls = await filesToDataURLs(e.target.files); addHwThumbs(urls); hwFile.value='';
  });
  hwPaste.addEventListener('click', async ()=>{
    try{ const urls = await clipboardToDataURLs(); addHwThumbs(urls); }
    catch{ alert('Clipboard read not supported here.'); }
  });
  hwDrop.addEventListener('dragover', (e)=>{ e.preventDefault(); hwDrop.classList.add('hover'); });
  hwDrop.addEventListener('dragleave', ()=> hwDrop.classList.remove('hover'));
  hwDrop.addEventListener('drop', async e=>{
    e.preventDefault(); hwDrop.classList.remove('hover');
    const urls = await filesToDataURLs(e.dataTransfer.files); addHwThumbs(urls);
  });
  hwClearImgs.addEventListener('click', ()=>{ hwImages=[]; renderHwThumbs(); });

  // Template clicks
  document.querySelectorAll('.hint').forEach(h=>{
    h.addEventListener('click', ()=>{
      hwPrompt.value = (hwPrompt.value ? hwPrompt.value + '\n' : '') + h.dataset.t;
    });
  });

  /* ---------- Payload Builders ---------- */
  function buildOpenAIFromChatHistory(){
    const msgs = [];
    for (const m of chatHistory){
      const content = [];
      if (m.text) content.push({ type:'input_text', text: m.text });
      if (m.images && m.images.length){
        for (const img of m.images) content.push({ type:'input_image', image_url: img });
      }
      msgs.push({ role: m.role, content });
    }
    return msgs;
  }
  function buildGeminiFromChatHistory(){
    const contents = [];
    for (const m of chatHistory){
      const parts = [];
      if (m.text) parts.push({ text: m.text });
      if (m.images && m.images.length){
        for (const img of m.images){
          const a = /^data:(.*?);base64,(.*)$/.exec(img);
          if (a) parts.push({ inline_data:{ mime_type: a[1]||'image/png', data: a[2] }});
        }
      }
      const role = m.role==='assistant' ? 'model' : 'user';
      contents.push({ role, parts });
    }
    return contents;
  }
  function buildClaudeFromChatHistory(){
    const msgs = [];
    for (const m of chatHistory){
      if (m.role==='system'){
        msgs.push({ role:'user', content:[{type:'text', text: m.text}] });
        continue;
      }
      const content = [];
      if (m.images && m.images.length){
        for (const img of m.images){
          const a = /^data:(.*?);base64,(.*)$/.exec(img);
          if (a) content.push({ type:'image', source:{ type:'base64', media_type: a[1]||'image/png', data: a[2] }});
        }
      }
      if (m.text) content.push({ type:'text', text: m.text });
      msgs.push({ role: m.role, content });
    }
    return msgs;
  }

  function buildOpenAIHomework(){
    const content = [];
    if (hwPrompt.value.trim()) content.push({type:'input_text', text: hwPrompt.value.trim()});
    for (const img of hwImages) content.push({ type:'input_image', image_url: img });
    return [{ role:'user', content }];
  }
  function buildGeminiHomework(){
    const parts = [];
    if (hwPrompt.value.trim()) parts.push({ text: hwPrompt.value.trim() });
    for (const img of hwImages){
      const a = /^data:(.*?);base64,(.*)$/.exec(img);
      if (a) parts.push({ inline_data:{ mime_type:a[1]||'image/png', data:a[2] }});
    }
    return [{ role:'user', parts }];
  }
  function buildClaudeHomework(){
    const content=[];
    for (const img of hwImages){
      const a = /^data:(.*?);base64,(.*)$/.exec(img);
      if (a) content.push({ type:'image', source:{ type:'base64', media_type:a[1]||'image/png', data:a[2] }});
    }
    if (hwPrompt.value.trim()) content.push({ type:'text', text: hwPrompt.value.trim() });
    return [{ role:'user', content }];
  }

  function extractOpenAI(resp){
    try{
      const arr=resp.output||[]; let txt='';
      for (const item of arr){
        if (item.type==='message' && item.content){
          for (const c of item.content){
            if (c.type==='output_text' && typeof c.text==='string') txt+=c.text;
            if (c.type==='text' && typeof c.text==='string') txt+=c.text;
          }
        }
        if (item.type==='output_text' && typeof item.text==='string') txt+=item.text;
      }
      return txt.trim() || JSON.stringify(resp,null,2);
    }catch(e){ return JSON.stringify(resp,null,2); }
  }
  function extractGemini(resp){
    try{
      const c = resp.candidates && resp.candidates[0];
      const p = c && c.content && c.content.parts;
      if (p && p.length){ return p.map(x=>x.text||'').join(''); }
      return JSON.stringify(resp,null,2);
    }catch(e){ return JSON.stringify(resp,null,2); }
  }
  function extractClaude(resp){
    try{
      const t = resp && resp.content && resp.content.map(p=>p.text||'').join('');
      return t || JSON.stringify(resp,null,2);
    }catch(e){ return JSON.stringify(resp,null,2); }
  }

  /* ---------- Send Chat ---------- */
  async function callChat(){
    const keyVal = apiKey.value.trim();
    if (!keyVal){ alert('Enter your API key.'); return; }
    const userText = chatInput.value.trim();
    if (!userText && nextUserImages.length===0){ alert('Type a message or attach an image.'); return; }

    const userMsg = { role:'user', text:userText, images: nextUserImages.slice() };
    chatHistory.push(userMsg);
    addBubble('user', userMsg.text, userMsg.images);
    chatInput.value=''; nextUserImages=[]; renderNextUserThumbs();

    let url, payload, headers = {}, method='POST';
    try{
      if (provider.value==='openai'){
        payload = { model:model.value, input: buildOpenAIFromChatHistory() };
        const current = MODELS.openai.list.find(x=>x.id===model.value);
        const canReason = current && current.reason;
        if (canReason && reasoningToggle.checked){ payload.reasoning = { effort: effort.value }; }
        url = (baseUrl.value.trim() || 'https://api.openai.com') + '/v1/responses';
        headers = { 'Content-Type':'application/json', 'Authorization':`Bearer ${keyVal}` };
      }else if (provider.value==='google'){
        url = `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(model.value)}:generateContent?key=${encodeURIComponent(keyVal)}`;
        payload = { contents: buildGeminiFromChatHistory() };
        headers = { 'Content-Type':'application/json' };
      }else{
        url = 'https://api.anthropic.com/v1/messages';
        payload = { model:model.value, max_tokens: 1024, messages: buildClaudeFromChatHistory() };
        headers = { 'Content-Type':'application/json', 'x-api-key': keyVal, 'anthropic-version':'2023-06-01' };
      }

      const resp = await fetch(url,{ method, headers, body: JSON.stringify(payload) });
      if (!resp.ok){ const t = await resp.text(); throw new Error(`HTTP ${resp.status}: ${t}`); }

      const data = await resp.json();
      const text = provider.value==='openai' ? extractOpenAI(data)
                 : provider.value==='google' ? extractGemini(data)
                 : extractClaude(data);

      const botMsg = { role:'assistant', text };
      chatHistory.push(botMsg);
      addBubble('assistant', text);
    }catch(err){
      addBubble('system', 'Error: '+String(err.message||err));
    }
  }
  sendChat.addEventListener('click', callChat);
  chatInput.addEventListener('keydown', (e)=>{ if (e.key==='Enter' && !e.shiftKey){ e.preventDefault(); callChat(); }});

  /* ---------- Homework Actions ---------- */
  async function callHomework(nextOnly=false){
    const keyVal = apiKey.value.trim();
    if (!keyVal){ alert('Enter your API key.'); return; }
    if (hwImages.length===0 && !hwPrompt.value.trim()){ alert('Add at least one image or a prompt.'); return; }

    hwOut.textContent = (nextOnly ? 'Requesting next hint…' : 'Analyzing…');

    let url, payload, headers={}, method='POST';
    try{
      if (provider.value==='openai'){
        payload = { model:model.value, input: buildOpenAIHomework() };
        const current = MODELS.openai.list.find(x=>x.id===model.value);
        const canReason = current && current.reason;
        if (canReason && reasoningToggle.checked){ payload.reasoning = { effort: effort.value }; }
        url = (baseUrl.value.trim() || 'https://api.openai.com') + '/v1/responses';
        headers = { 'Content-Type':'application/json', 'Authorization':`Bearer ${keyVal}` };
      }else if (provider.value==='google'){
        url = `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(model.value)}:generateContent?key=${encodeURIComponent(keyVal)}`;
        payload = { contents: buildGeminiHomework() };
        headers = { 'Content-Type':'application/json' };
      }else{
        url = 'https://api.anthropic.com/v1/messages';
        payload = { model:model.value, max_tokens: 1024, messages: buildClaudeHomework() };
        headers = { 'Content-Type':'application/json', 'x-api-key': keyVal, 'anthropic-version':'2023-06-01' };
      }
      if (nextOnly){
        if (provider.value==='openai'){
          payload.input.unshift({ role:'system', content:[{type:'input_text', text:'Give only the next hint. Do not reveal the final answer yet.'}]});
        }else if (provider.value==='google'){
          payload.contents.unshift({ role:'user', parts:[{text:'Give only the next hint. Do not reveal the final answer yet.'}]});
        }else{
          payload.messages.unshift({ role:'user', content:[{type:'text', text:'Give only the next hint. Do not reveal the final answer yet.'}]});
        }
      }

      const resp = await fetch(url,{ method, headers, body: JSON.stringify(payload) });
      if (!resp.ok){ const t=await resp.text(); throw new Error(`HTTP ${resp.status}: ${t}`); }
      const data = await resp.json();
      const text = provider.value==='openai' ? extractOpenAI(data)
                 : provider.value==='google' ? extractGemini(data)
                 : extractClaude(data);
      hwOut.textContent = text;
    }catch(err){
      hwOut.innerHTML = `<span class="warnTxt">Error:</span> ${String(err.message||err)}`;
    }
  }
  askHw.addEventListener('click', ()=>callHomework(false));
  nextHint.addEventListener('click', ()=>callHomework(true));
</script>
</body>
</html>